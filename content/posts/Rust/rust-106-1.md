+++
title = "Rust 106-1: Defining an Enum"
date = "2026-07-17"
tags = ["rust", "enums", "option", "data-types", "programming"]
categories = ["posts"]
series = ["Rust 106"]
type = "post"
draft = false
math = false
description = "Explore Rust enums, from basic definitions to attaching data and using the powerful Option enum."
+++

Welcome to Rust 106-1! Enums (enumerations) allow you to define a type by enumerating its possible *variants*. While structs group related fields together, enums let you say a value is one of a possible set of values. In this post, we'll cover defining enums, attaching data to them, and the critical `Option` enum.

## Defining an Enum

Let's say we need to work with IP addresses. They can be either version four or version six. We can express this with an enum:

```rust
enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
    
    route(four);
    route(six);
}

fn route(ip_kind: IpAddrKind) {
    // Route based on IP kind
}
```

The variants are namespaced under the enum identifier method syntax `IpAddrKind::V4`.

## Enums with Data

We often want to store data associated with the variant. Instead of using a struct with an enum field, we can put data directly into each enum variant.

```rust
#[derive(Debug)]
enum IpAddr {
    V4(String),
    V6(String),
}

fn main() {
    let home = IpAddr::V4(String::from("127.0.0.1"));
    let loopback = IpAddr::V6(String::from("::1"));

    println!("{:?}", home);
    println!("{:?}", loopback);
}
```

Each variant can store different types and amounts of data:

```rust
#[derive(Debug)]
enum IpAddr {
    V4(u8, u8, u8, u8), // Four u8 values
    V6(String),         // One String
}

fn main() {
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));

    println!("{:?}", home);
}
```

This flexibility allows you to represent complex data structures concisely.

### A Richer Example: Message Enum

Enums can define a variety of embedded types, even anonymous structs:

```rust
enum Message {
    Quit,                       // No data
    Move { x: i32, y: i32 },    // Named fields like a struct
    Write(String),              // Single String
    ChangeColor(i32, i32, i32), // Tuple of three i32s
}
```

## Methods on Enums

Just like structs, you can define methods on enums using `impl`:

```rust
impl Message {
    fn call(&self) {
        // Method body would logic based on self
        println!("Message called!");
    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}
```

## The `Option` Enum

Rust doesn't have the `null` feature found in many other languages. Instead, it uses the `Option<T>` enum to encode the scenario where a value could be something or nothing.

It is defined in the standard library as:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T>` is so common that it's included in the prelude; you don't need to import it, and you can use `Some` and `None` directly.

```rust
fn main() {
    let some_number = Some(5);
    let some_char = Some('e');
    
    // Explicit type annotation needed for None
    let absent_number: Option<i32> = None;
    
    println!("Number: {:?}", some_number);
    println!("Absent: {:?}", absent_number);
}
```

### Why is this better than null?

The key advantage is that `Option<T>` and `T` are different types. You cannot use an `Option<T>` as if it were a valid value without handling the `None` case.

```rust
fn main() {
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    // let sum = x + y; // ERROR: cannot add Option<i8> to i8
}
```

To use the value inside `y`, you must handle the case where it might be `None`, preventing null pointer exceptions at compile time.

## Summary

Enums are a powerful feature in Rust for creating types that can be one of several variants.
- They can hold different types of data in each variant.
- You can define methods on them.
- The `Option` enum replaces nulls, forcing you to handle the absence of values explicitly.

In the next post, we'll look at the `match` control flow construct, which allows us to effectively use the data stored in enums.

Stay tuned for more Rust!
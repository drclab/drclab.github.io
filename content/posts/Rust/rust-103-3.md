+++
title = "Rust 103-3: Functions"
date = "2026-07-06"
tags = ["rust", "functions", "parameters", "expressions", "statements", "return-values", "programming"]
categories = ["posts"]
series = ["Rust 101"]
type = "post"
draft = false
math = true
description = "An exploration of Rust functions: parameters, statements vs expressions, and return values."
+++

In the previous post, [Rust 103-2]({{< ref "rust-103-2.md" >}}), we explored Rust's data types. Now we'll dive into functions, based on [Chapter 3.3 of The Rust Programming Language](https://rust-book.cs.brown.edu/ch03-03-how-functions-work.html).

## Function Basics

Functions are prevalent in Rust code. You've already seen the most important function: `main`, which is the entry point of many programs. The `fn` keyword allows you to declare new functions.

Rust uses **snake_case** as the conventional style for function and variable names—all letters lowercase with underscores separating words.

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```

Key points:
- Define a function with `fn` followed by the function name and parentheses
- Curly brackets `{}` define the function body
- **Order doesn't matter**: You can define `another_function` before or after `main`—Rust only requires that functions are defined somewhere in a scope visible to the caller

Running this code produces:
```
Hello, world!
Another function.
```

## Parameters

Functions can have **parameters**—special variables that are part of the function's signature. When a function has parameters, you provide concrete values (called **arguments**) when calling it.

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
```

Output:
```
The value of x is: 5
```

### Type Annotations Are Required

In function signatures, you **must** declare the type of each parameter. This is a deliberate design decision:
- The compiler almost never needs type annotations elsewhere in your code
- The compiler can provide more helpful error messages when it knows expected types

### Multiple Parameters

Separate multiple parameters with commas:

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}
```

Output:
```
The measurement is: 5h
```

## Statements and Expressions

Understanding the difference between statements and expressions is crucial in Rust because it's an **expression-based language**.

| Concept | Description | Returns a Value? |
|---------|-------------|------------------|
| **Statement** | An instruction that performs an action | ❌ No |
| **Expression** | Evaluates to a resultant value | ✅ Yes |

### Statements

Creating a variable with `let` is a statement:

```rust
fn main() {
    let y = 6; // This is a statement
}
```

Function definitions are also statements. **Statements do not return values**, so you cannot assign a `let` statement to another variable:

```rust
fn main() {
    let x = (let y = 6); // Error!
}
```

This produces:
```
error: expected expression, found `let` statement
```

This differs from languages like C and Ruby, where assignment returns the assigned value (allowing `x = y = 6`).

### Expressions

Expressions evaluate to a value and make up most of Rust code:

| Expression Type | Example |
|----------------|---------|
| Math operation | `5 + 6` |
| Literal value | `6` |
| Function call | `another_function()` |
| Macro call | `println!()` |
| Scope block | `{ ... }` |

A scope block created with curly brackets is an expression:

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}"); // Prints: 4
}
```

The block `{ let x = 3; x + 1 }` evaluates to `4`, which gets bound to `y`.

### The Semicolon Rule

**Critical**: Notice that `x + 1` has **no semicolon**. This is what makes it an expression that returns a value.

- **Without semicolon**: Expression → returns a value
- **With semicolon**: Statement → returns `()` (unit type)

```rust
// This returns 4
{
    let x = 3;
    x + 1
}

// This returns () - the unit type
{
    let x = 3;
    x + 1;
}
```

## Functions with Return Values

Functions can return values to their callers. Declare the return type after an arrow (`->`):

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();
    println!("The value of x is: {x}"); // Prints: 5
}
```

Key observations:
- The `five` function has no parameters and just contains `5`—a valid function!
- The return value is the **final expression** in the function body
- No `return` keyword needed for the last expression
- No semicolon after `5` (it's an expression, not a statement)

### The `return` Keyword

You can use `return` to exit early from a function with a value:

```rust
fn absolute_value(x: i32) -> i32 {
    if x < 0 {
        return -x;
    }
    x
}
```

But most functions return the last expression implicitly.

### A More Complex Example

```rust
fn main() {
    let x = plus_one(5);
    println!("The value of x is: {x}"); // Prints: 6
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

### Common Mistake: Accidental Semicolon

Adding a semicolon to the return expression is a common error:

```rust
fn plus_one(x: i32) -> i32 {
    x + 1; // Oops! This is now a statement
}
```

This produces:
```
error[E0308]: mismatched types
 --> src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value
```

The function signature promises `i32`, but the statement `x + 1;` returns `()` (unit type).

## Putting It All Together

Here's a practical example combining all concepts:

```rust
fn main() {
    let width = 5;
    let height = 10;
    
    let area = calculate_area(width, height);
    println!("The area is: {area}");
    
    let description = describe_rectangle(width, height);
    println!("{description}");
}

fn calculate_area(width: i32, height: i32) -> i32 {
    width * height  // Expression - no semicolon
}

fn describe_rectangle(width: i32, height: i32) -> String {
    let area = calculate_area(width, height);
    let perimeter = 2 * (width + height);
    
    // Block expression as return value
    format!("Rectangle: {}x{}, area={}, perimeter={}", 
            width, height, area, perimeter)
}
```

## Summary

| Concept | Key Points |
|---------|------------|
| **Function definition** | `fn name(params) -> ReturnType { body }` |
| **Naming convention** | `snake_case` for functions and variables |
| **Parameters** | Types must be annotated: `fn foo(x: i32, y: char)` |
| **Statements** | Perform actions, return no value, end with `;` |
| **Expressions** | Evaluate to values, no ending `;` for return |
| **Return values** | Declared with `-> Type`, last expression returned |
| **Early return** | Use `return value;` to exit early |

### Quick Reference

```rust
// Function with no parameters, no return
fn greet() {
    println!("Hello!");
}

// Function with parameters, no return
fn greet_person(name: &str) {
    println!("Hello, {name}!");
}

// Function with return value
fn add(a: i32, b: i32) -> i32 {
    a + b  // No semicolon!
}

// Function with early return
fn safe_divide(a: f64, b: f64) -> Option<f64> {
    if b == 0.0 {
        return None;
    }
    Some(a / b)
}
```

In the next post, we'll explore comments and then control flow in Rust.


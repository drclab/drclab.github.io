+++
title = "Rust 108-2: Storing UTF-8 Encoded Text with Strings"
date = "2026-01-26"
tags = ["rust", "strings", "utf-8", "collections", "text", "encoding"]
categories = ["posts"]
series = ["Rust 108"]
type = "post"
draft = false
math = false
description = "Explore Rust's string types, including String and &str, with UTF-8 encoding, creation, updating, and safe text handling."
+++

Welcome to Rust 108-2! In this post, we'll dive into Rust's string handling, focusing on the `String` type and string slices (`&str`). Strings in Rust are UTF-8 encoded, making them suitable for international text, but this also introduces complexities around indexing and iteration. We'll cover creating strings, updating them, and the safe ways to access their contents.

## What Is a String?

Rust has two main string types:

- `&str`: A string slice, usually seen as a borrowed reference, pointing to UTF-8 encoded text stored elsewhere.
- `String`: A growable, mutable, owned string type from the standard library.

Both are UTF-8 encoded, allowing support for text in any language.

## Creating a New String

You can create strings in several ways:

### Using `String::new()`

```rust
let mut s = String::new();
```

This creates an empty string.

### Using `to_string()` or `String::from()`

```rust
let data = "initial contents";
let s = data.to_string();
// or
let s = "initial contents".to_string();
// or
let s = String::from("initial contents");
```

These create a `String` from a string literal.

Strings support UTF-8, so you can include any properly encoded text:

```rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
// And many more...
```

## Updating a String

### Appending with `push_str` and `push`

```rust
let mut s = String::from("foo");
s.push_str("bar");  // s is now "foobar"
```

`push_str` appends a string slice without taking ownership.

```rust
let mut s = String::from("lo");
s.push('l');  // s is now "lol"
```

`push` adds a single character.

### Concatenation with `+` or `format!`

Using the `+` operator:

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2;  // s1 is moved, s3 is "Hello, world!"
```

Note that `s1` is moved into the operation.

For multiple concatenations, use `format!`:

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{s1}-{s2}-{s3}");  // "tic-tac-toe"
```

`format!` doesn't take ownership of its parameters.

## Indexing into Strings

Direct indexing into strings is not allowed in Rust because strings are UTF-8 encoded, and byte indices don't always correspond to character boundaries.

```rust
let s1 = String::from("hi");
// let h = s1[0];  // This won't compile
```

Instead, use methods like `chars()` or `bytes()`.

## Slicing Strings

You can slice strings using byte ranges, but be careful:

```rust
let hello = "Здравствуйте";
let s = &hello[0..4];  // "Зд"
```

Slicing in the middle of a character will panic at runtime.

## Methods for Iterating Over Strings

### Iterating over Characters

```rust
for c in "Зд".chars() {
    println!("{c}");
}
// Prints: З
//         д
```

### Iterating over Bytes

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
// Prints: 208
//         151
//         208
//         180
```

For grapheme clusters (user-perceived characters), you may need external crates.

## Strings Are Not So Simple

Strings in Rust prioritize correctness over simplicity. UTF-8 encoding means you can't assume byte indices equal character positions. Rust's design prevents common bugs by making you explicit about how you access string data. The standard library provides many methods for string manipulation—check the docs for `contains`, `replace`, and more.

In the next post, we'll explore hash maps, another essential collection type.
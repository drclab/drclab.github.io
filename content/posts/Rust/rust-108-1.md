+++
title = "Rust 108-1: Storing Lists of Values with Vectors"
date = "2026-01-25"
tags = ["rust", "vectors", "collections", "data structures", "memory", "borrowing"]
categories = ["posts"]
series = ["Rust 108"]
type = "post"
draft = false
math = false
description = "Learn how to store lists of values with vectors in Rust, including creating, updating, reading, and iterating over vectors."
+++

Welcome to Rust 108-1! In this post, we'll explore vectors, Rust's primary collection type for storing lists of values. Vectors allow you to store multiple values of the same type in a single data structure, with all elements stored contiguously in memory. We'll cover creating vectors, adding and accessing elements, iterating over them, and understanding the borrowing rules that keep your code safe.

## Creating a New Vector

To create a new vector, you can use the `Vec::new()` function or the `vec!` macro.

### Using `Vec::new()`

```rust
let v: Vec<i32> = Vec::new();
```

This creates an empty vector that will hold `i32` values. Note that you need to specify the type because Rust can't infer it from an empty vector.

### Using the `vec!` Macro

```rust
let v = vec![1, 2, 3];
```

This creates a vector with initial values. Rust infers the type as `Vec<i32>` from the integer literals.

## Updating a Vector

Vectors are immutable by default, but you can make them mutable to add elements.

```rust
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

The `push` method adds elements to the end of the vector.

## Reading Elements of Vectors

There are two ways to access vector elements: indexing and the `get` method.

### Indexing

```rust
let v = vec![1, 2, 3, 4, 5];
let third: &i32 = &v[2];
println!("The third element is {}", third);
```

Indexing returns a reference to the element. If you try to access an index out of bounds, the program will panic.

### Using `get`

```rust
let v = vec![1, 2, 3, 4, 5];
let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}
```

The `get` method returns an `Option<&T>`, allowing you to handle out-of-bounds access gracefully.

### Borrowing Rules with Vectors

Remember the borrowing rules: you can't have mutable and immutable references to the same vector simultaneously. This prevents issues when the vector needs to reallocate memory.

```rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];  // Immutable borrow
v.push(6);          // Mutable borrow - this would cause a compile error
println!("The first element is: {}", first);
```

This code won't compile because pushing to the vector might invalidate the reference to the first element.

## Iterating Over the Values in a Vector

To process each element, use a `for` loop.

### Immutable Iteration

```rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}
```

### Mutable Iteration

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;  // Dereference to modify
}
```

## Using an Enum to Store Multiple Types

Vectors can only store values of the same type. To store different types, use an enum:

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

## Dropping a Vector Drops Its Elements

When a vector goes out of scope, it and its elements are dropped automatically.

```rust
{
    let v = vec![1, 2, 3, 4];
    // use v
} // v and its elements are freed here
```

Vectors are a fundamental collection in Rust, providing efficient storage and access to sequences of data. Understanding their borrowing semantics is key to writing safe Rust code. In the next post, we'll look at strings, another important collection type.
+++
title = "Rust 107-4: Bringing Paths into Scope with the use Keyword"
date = "2026-07-23"
tags = ["rust", "use", "paths", "imports", "modules", "re-export", "external-crates", "programming"]
categories = ["posts"]
series = ["Rust 107"]
type = "post"
draft = false
math = false
description = "Simplify Rust code with the use keyword: import paths, re-export, and best practices for clean, readable modules."
+++

Welcome to Rust 107-4! Writing full paths repeatedly is tedious. The `use` keyword brings items into scope, creating shortcuts. This post covers `use`, idioms, renaming, re-exporting, and external packages.

## Bringing Paths into Scope with use

`use` creates shortcuts for paths. It's like a symbolic link.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {
            println!("Added to waitlist!");
        }
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

Here, `use crate::front_of_house::hosting;` lets us call `hosting::add_to_waitlist()` instead of the full path.

**Scope Note:** `use` applies only to its scope. Moving `eat_at_restaurant` to a submodule requires its own `use`.

## Creating Idiomatic use Paths

Idioms make code readable:

- For functions: Bring parent module, not the function itself.

```rust
use crate::front_of_house::hosting; // Idiomatic

// Not idiomatic:
// use crate::front_of_house::hosting::add_to_waitlist;
```

- For types (structs, enums): Bring the full path.

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

For same-name items, use parent modules:

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    Ok(())
}

fn function2() -> io::Result<()> {
    Ok(())
}
```

## Providing New Names with the as Keyword

Rename with `as` to avoid conflicts:

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    Ok(())
}

fn function2() -> IoResult<()> {
    Ok(())
}
```

## Re-exporting Names with pub use

`pub use` re-exports items, making them available externally as if defined locally.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

External code can now use `restaurant::hosting::add_to_waitlist()` instead of the full path.

## Using External Packages

Add dependencies in `Cargo.toml`, then `use` them.

Example with `rand`:

```rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
    println!("Secret: {}", secret_number);
}
```

For standard library: `use std::collections::HashMap;`.

## Using Nested Paths to Clean Up Large use Lists

Group common paths:

```rust
// Instead of:
// use std::cmp::Ordering;
// use std::io;

use std::{cmp::Ordering, io};
```

Include `self` for subpaths:

```rust
use std::io::{self, Write};
```

## The Glob Operator

Bring all public items with `*`:

```rust
use std::collections::*;
```

Use cautiouslyâ€”it can cause name conflicts and obscure origins.

## Summary

`use` simplifies paths, `as` renames, `pub use` re-exports. Follow idioms for readable code. External crates work the same way.

Next, we'll separate modules into different files.

Stay tuned for more Rust!
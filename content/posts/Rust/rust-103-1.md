+++
title = "Rust 103-1: Variables and Mutability"
date = "2026-01-04"
tags = ["rust", "variables", "mutability", "shadowing", "programming"]
categories = ["posts"]
series = ["Rust 101"]
type = "post"
draft = false
math = true
description = "A deep dive into Rust variables, mutability, constants, and shadowing."
+++

In the previous post, [Rust 102]({{< ref "rust-102.md" >}}), we built a guessing game and briefly touched on variables. Now, we'll dive deeper into the core concepts of variables, mutability, constants, and shadowing in Rust, based on [Chapter 3.1 of The Rust Programming Language](https://doc.rust-lang.org/stable/book/ch03-01-variables-and-mutability.html).

## Variables and Mutability

By default, variables in Rust are **immutable**. This means once a value is bound to a name, you cannot change that value. This is a safety feature to ensure that if a part of your code expects a value to remain constant, it will not be changed unexpectedly by another part of the code.

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6; // This will cause a compile-time error
    println!("The value of x is: {x}");
}
```

To make a variable mutable, you must use the `mut` keyword. This conveys intent to future readers that the variable's value will change.

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

## Constants

Constants are values that are bound to a name and are not allowed to change. They differ from variables in a few ways:

1.  **No `mut`**: You cannot use `mut` with constants; they are always immutable.
2.  **`const` keyword**: You declare constants using `const` instead of `let`.
3.  **Type annotation required**: You must always annotate the type of a constant.
4.  **Scope**: Constants can be declared in any scope, including the global scope.
5.  **Constant expression**: Constants must be set to a constant expression, not a value computed at runtime.

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

Naming convention for constants is all uppercase with underscores between words.

## Shadowing

Shadowing occurs when you declare a new variable with the same name as a previous variable. The new variable *shadows* the previous one.

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}"); // Prints 12
    }

    println!("The value of x is: {x}"); // Prints 6
}
```

### Shadowing vs Mutability

Shadowing is different from marking a variable as `mut`:
1.  **Re-assignment**: You must use the `let` keyword again. This effectively creates a new variable.
2.  **Immutability**: After the shadowing `let` statement, the variable is immutable again (unless declared with `mut`).
3.  **Type Change**: Because it's a new variable, you can change the type of the value while reusing the same name.

```rust
let spaces = "   ";
let spaces = spaces.len(); // Allowed: spaces is now a number
```

If you tried this with `mut`, it would fail because you cannot mutate a variable's type:

```rust
let mut spaces = "   ";
spaces = spaces.len(); // Error: expected `&str`, found `usize`
```

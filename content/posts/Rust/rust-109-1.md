+++
title = "Rust 109-1: Unrecoverable Errors with Panic"
date = "2026-01-28"
tags = ["rust", "error handling", "panic", "unwinding", "backtrace"]
categories = ["posts"]
series = ["Rust 109"]
type = "post"
draft = false
math = false
description = "Learn about unrecoverable errors in Rust using the panic! macro, including stack unwinding, backtraces, and when to use panic."
+++

Welcome to Rust 109-1! In Rust, some errors are unrecoverableâ€”situations where your program can't continue safely. The `panic!` macro stops execution immediately. In this post, we'll explore panics, how Rust handles them, and when to use them.

## The panic! Macro

When your code encounters an unrecoverable error, call `panic!`:

```rust
fn main() {
    panic!("crash and burn");
}
```

This prints an error message and exits. The message shows the file and line where the panic occurred.

## Unwinding the Stack or Aborting

By default, Rust unwinds the stack on panic, cleaning up data from each function. This is thorough but slow. For smaller binaries, you can abort instead:

In Cargo.toml:

```toml
[profile.release]
panic = 'abort'
```

Aborting ends the program without cleanup, leaving memory management to the OS.

## Panics from Library Code

Panics can occur in library code due to bugs in your code. For example, accessing an invalid vector index:

```rust
fn main() {
    let v = vec![1, 2, 3];
    v[99];  // Panics: index out of bounds
}
```

Rust panics to prevent undefined behavior like buffer overruns.

## Using Backtraces

To debug panics, set `RUST_BACKTRACE=1`:

```bash
RUST_BACKTRACE=1 cargo run
```

This shows the call stack, helping trace the error's origin. Start from the top and look for your code.

Panics are for unrecoverable errors. For recoverable errors, use `Result`, which we'll cover next.
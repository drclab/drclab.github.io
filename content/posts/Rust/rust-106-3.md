+++
title = "Rust 106-3: Concise Control Flow with if let and let else"
date = "2026-01-19"
tags = ["rust", "if-let", "let-else", "control-flow", "patterns", "enums", "option", "programming"]
categories = ["posts"]
series = ["Rust 106"]
type = "post"
draft = false
math = false
description = "Learn Rust's concise control flow constructs: if let for handling single patterns and let else for staying on the happy path."
+++

Welcome to Rust 106-3! In the previous posts, we explored enums and the `match` control flow construct. While `match` is powerful and exhaustive, sometimes you only care about one specific pattern. Rust provides `if let` and `let else` for more concise control flow in such cases.

## Concise Control Flow with if let

The `if let` syntax combines `if` and `let` to handle values matching one pattern while ignoring the rest. It's like a `match` that only cares about one case.

Consider this `match` example:

```rust
fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {max}"),
        _ => (),
    }
}
```

This works, but the `_ => ()` is boilerplate. With `if let`, it's shorter:

```rust
fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {max}");
    }
}
```

**Key point:** `if let` runs code only if the value matches the pattern. It lacks `match`'s exhaustive checking, so use it when you intentionally ignore other cases.

You can add an `else` for the ignored cases:

```rust
#[derive(Debug)]
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn main() {
    let coin = Coin::Quarter;
    let mut count = 0;
    if let Coin::Quarter = coin {
        println!("Found a quarter!");
    } else {
        count += 1;
    }
    println!("Non-quarter coins: {}", count);
}
```

Here, if it's a quarter, we print a message; else, increment the count.

## Staying on the "Happy Path" with let else

`let else` is for scenarios where you want to bind a value if it matches, or handle the mismatch (often by returning early). It's great for keeping the main logic on the "happy path."

Using the coin example with state quarters:

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
}

#[derive(Debug)]
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

impl UsState {
    fn existed_in(&self, year: u16) -> bool {
        match self {
            UsState::Alabama => year >= 1819,
            UsState::Alaska => year >= 1959,
        }
    }
}

fn describe_state_quarter(coin: Coin) -> Option<String> {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}

fn main() {
    let coin = Coin::Quarter(UsState::Alaska);
    if let Some(desc) = describe_state_quarter(coin) {
        println!("{}", desc);
    }
}
```

**Highlight:** `let else` binds `state` if it's a `Quarter`, else returns `None`. This keeps the function's main body focused on the success case.

Compare to `if let`:

```rust
fn describe_state_quarter_if_let(coin: Coin) -> Option<String> {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("{state:?} is pretty old, for America!"))
        } else {
            Some(format!("{state:?} is relatively new."))
        }
    } else {
        None
    }
}
```

`let else` is cleaner for early returns.

## Summary

- Use `if let` for concise handling of single patterns, trading exhaustiveness for brevity.
- Use `let else` to stay on the happy path, binding values or returning early on mismatch.

These constructs make Rust code more readable when you don't need full `match` coverage. In the next post, we'll explore more Rust features!

Stay tuned for more Rust!
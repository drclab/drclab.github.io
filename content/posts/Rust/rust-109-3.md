+++
title = "Rust 109-3: To panic! or Not to panic!"
date = "2026-01-30"
tags = ["rust", "error handling", "panic", "validation", "custom types"]
categories = ["posts"]
series = ["Rust 109"]
type = "post"
draft = false
math = false
description = "Learn when to use panic! versus Result in Rust, including guidelines for error handling and creating custom types for validation."
+++

Welcome to Rust 109-3! Now that we've covered `panic!` for unrecoverable errors and `Result` for recoverable ones, let's explore how to decide which to use in different situations.

## When to panic! vs Return Result

When code panics, there's no way to recover. You could call `panic!` for any error situation, but you'd be making the decision that a situation is unrecoverable on behalf of the calling code.

When you return a `Result` value, you give the calling code options:
- Attempt to recover in a way appropriate for its situation
- Decide that this `Err` is unrecoverable and call `panic!`

**Returning `Result` is a good default choice when you're defining a function that might fail.**

## Examples, Prototype Code, and Tests

In these situations, it's more appropriate to write code that panics:

### Examples

When writing an example to illustrate a concept, robust error-handling code can make the example less clear. A call to `unwrap` is understood as a placeholder for the way you'd want your application to handle errors.

### Prototype Code

The `unwrap` and `expect` methods are very handy when prototyping, before you're ready to decide how to handle errors. They leave clear markers in your code for when you're ready to make your program more robust.

### Tests

If a method call fails in a test, you'd want the whole test to fail, even if that method isn't the functionality under test. Because `panic!` is how a test is marked as a failure, calling `unwrap` or `expect` is exactly what should happen.

## When You Have More Information Than the Compiler

Sometimes you have logic that ensures the `Result` will have an `Ok` value, but the compiler can't understand it:

```rust
use std::net::IpAddr;

fn main() {
    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
}
```

We can see that `127.0.0.1` is a valid IP address, so using `expect` here is acceptable. The `parse` method still returns a `Result` because the compiler can't verify string contents at compile time. By documenting why we believe failure is impossible, we create a reminder to handle this properly if the IP address ever comes from user input.

## Guidelines for Error Handling

### When to panic!

It's advisable to have your code panic when it could end up in a **bad state**—when some assumption, guarantee, contract, or invariant has been broken:

- **The bad state is unexpected**, not something that happens occasionally (like malformed user input)
- **Your code relies on not being in this bad state**, rather than checking at every step
- **There's no good way to encode this in the type system**

### When to Return Result

When failure is expected, return a `Result`:

- A parser being given malformed data
- An HTTP request returning a rate limit status
- Any expected possibility the calling code must handle

### Security Considerations

When an operation could put users at risk with invalid values:
1. Verify values are valid first
2. Panic if values aren't valid

This is why the standard library panics on out-of-bounds memory access—it's a common security problem.

### Function Contracts

Functions often have contracts: their behavior is only guaranteed if inputs meet certain requirements. Panicking when the contract is violated makes sense because:
- A contract violation always indicates a caller-side bug
- It's not a kind of error the calling code should explicitly handle
- There's no reasonable way for calling code to recover

## Leveraging the Type System

Instead of many runtime checks, use Rust's type system:

```rust
// Instead of checking for None everywhere...
fn process_value(value: Option<i32>) {
    if let Some(v) = value {
        // do something
    }
}

// ...require a value
fn process_value(value: i32) {
    // The compiler ensures we have a value
}
```

Using `u32` instead of `i32` ensures the parameter is never negative—no runtime check needed.

## Creating Custom Types for Validation

Rather than repeating validation checks, create a custom type. Consider a guessing game where guesses must be between 1 and 100:

### The Manual Approach

```rust
let guess: i32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};

if guess < 1 || guess > 100 {
    println!("The secret number will be between 1 and 100.");
    continue;
}
```

This works but repeating this check in every function would be tedious.

### The Custom Type Approach

Create a type that enforces validity at construction:

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }
        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

### Key Design Points

1. **The `value` field is private**: Code outside the module can't set it directly
2. **Only `Guess::new` creates instances**: This enforces the validation
3. **A getter method provides access**: The `value()` method returns the validated value

Functions that need values between 1 and 100 can now declare `Guess` in their signature instead of `i32`, with no additional checks needed.

## Decision Summary

| Situation | Recommendation |
|-----------|----------------|
| Examples and documentation | `unwrap` / `expect` |
| Prototype code | `unwrap` / `expect` |
| Tests | `unwrap` / `expect` |
| Hardcoded values you know are valid | `expect` with explanation |
| Expected failures (user input, network) | Return `Result` |
| Contract violations / bugs | `panic!` |
| Security-critical invalid values | `panic!` |
| Repeating the same validation | Create a custom type |

## Summary

Rust's error-handling features are designed to help you write more robust code:

- **`panic!`** signals that your program is in a state it can't handle
- **`Result`** indicates operations might fail in a way your code could recover from

Using `panic!` and `Result` in appropriate situations makes your code more reliable in the face of inevitable problems.

Next, we'll explore how generics work and how you can use them in your code!

+++
title = "Rust 104-1: What is Ownership?"
date = "2026-01-09"
tags = ["rust", "ownership", "memory-safety", "programming"]
categories = ["posts"]
series = ["Rust 104"]
type = "post"
draft = true
math = false
description = "An introduction to Rust's ownership system, explaining how it ensures memory safety and prevents undefined behavior."
+++

Welcome to Rust 104-1! In this post, we'll dive into one of Rust's most fundamental concepts: **ownership**. Ownership is the key to Rust's memory safety guarantees, allowing you to write efficient, concurrent programs without the fear of common bugs like null pointer dereferences or data races.

## Safety: The Absence of Undefined Behavior

Before we talk about ownership, let's understand what "safety" means in Rust. A safe program is one that never exhibits **undefined behavior**. Undefined behavior occurs when a program does something that the language specification doesn't define, leading to unpredictable results—like crashes, security vulnerabilities, or silent data corruption.

For example, consider this simple program:

```rust
fn read(y: bool) {
    if y {
        println!("y is true!");
    }
}

fn main() {
    let x = true;
    read(x);
}
```

This is safe because `x` is defined before it's used. But if we try to use `x` before defining it, Rust prevents compilation, avoiding potential undefined behavior.

Rust achieves this by checking programs at compile-time rather than runtime, catching bugs early and eliminating the need for many runtime checks.

## Ownership as a Discipline for Memory Safety

Ownership is Rust's way of managing memory safely. It ensures that:

1. All heap-allocated data is owned by exactly one variable at a time.
2. When the owner goes out of scope, the data is automatically deallocated.
3. Ownership can be transferred (moved) between variables.

Let's explore how this works with different types of data.

### Stack Variables

Simple values like integers live on the **stack**. Each function call gets its own stack frame, and variables are copied when assigned or passed to functions.

```rust
fn main() {
    let n = 5;
    let y = plus_one(n);
    println!("The value of y is: {}", y);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

Here, `n` and `x` each have their own copies of the value 5.

### Heap Allocation with Boxes

For larger data or data that needs to live beyond a single scope, Rust uses the **heap**. The `Box<T>` type allocates data on the heap and provides a pointer to it.

```rust
let a = Box::new([0; 1_000_000]); // Allocates a large array on the heap
let b = a; // Moves ownership from a to b
```

After the move, `a` can no longer be used—it's been "moved" to `b`. This prevents double-freeing or accessing freed memory.

### Collections and Ownership

Rust's collections like `Vec`, `String`, and `HashMap` use heap allocation internally and follow ownership rules.

```rust
fn main() {
    let first = String::from("Ferris");
    let full = add_suffix(first); // first is moved here
    println!("{}", full);
    // println!("{}", first); // This would be an error - first has been moved
}

fn add_suffix(mut name: String) -> String {
    name.push_str(" Jr.");
    name
}
```

The `first` string is moved into `add_suffix`, modified, and returned. Trying to use `first` afterward would cause a compile error.

### Cloning to Avoid Moves

If you need to keep the original data, you can clone it:

```rust
let first = String::from("Ferris");
let first_clone = first.clone(); // Deep copy
let full = add_suffix(first_clone);
println!("{}, originally {}", full, first); // first is still valid
```

## Why Ownership Matters

Ownership prevents common memory-related bugs:

- **No null pointer dereferences**: You can't accidentally access freed memory.
- **No double-freeing**: Each piece of heap data has exactly one owner.
- **No data races**: Ownership rules make concurrent programming safer.

By enforcing these rules at compile-time, Rust eliminates entire classes of bugs that plague other systems languages.

## Summary

Ownership is Rust's secret weapon for memory safety. It might feel restrictive at first, but it enables you to write fast, reliable code with confidence. As you continue learning Rust, you'll see how borrowing and lifetimes extend these concepts to allow more flexible code while maintaining safety.

In the next post, we'll explore references and borrowing, which let you temporarily lend access to data without transferring ownership.

Stay tuned for more Rust adventures!
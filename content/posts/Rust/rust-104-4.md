+++
title = "Rust 104-4: The Slice Type"
date = "2026-01-12"
tags = ["rust", "slices", "string-slice", "ownership", "borrowing", "programming"]
categories = ["posts"]
series = ["Rust 104"]
type = "post"
draft = false
math = false
description = "Understanding Rust slices: how they prevent bugs, why certain patterns cause errors, and best practices for using string and array slices."
+++

In the previous post, [Rust 104-3]({{< ref "rust-104-3.md" >}}), we explored common ownership errors and how to fix them. Now we'll dive into **slices**—a powerful abstraction that references a contiguous sequence of elements without owning them. This post is based on [Chapter 4.4 of The Rust Programming Language](https://rust-book.cs.brown.edu/ch04-04-slices.html).

## The Problem: Index-Based Approaches Are Error-Prone

Let's start with a common programming task: finding the first word in a string. Without slices, we might return an index:

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

This returns the **index** of the first space (or the string length if no space exists). But there's a subtle bug waiting to happen:

```rust
fn main() {
    let mut s = String::from("hello world");
    
    let word = first_word(&s);  // word = 5
    
    s.clear();  // Empties the string!
    
    // word is still 5, but s is now empty
    // Using word with s would be a bug!
}
```

**This compiles without errors!** The index `word` is completely disconnected from `s`. After `s.clear()`, `word` holds a stale value that no longer makes sense. This is a **logic bug** that Rust's ownership system can't catch with the index approach.

## The Solution: Slices

Slices solve this problem by maintaining a **connection** between the reference and the underlying data. A slice is a reference to a contiguous portion of a collection.

### String Slices

A string slice (`&str`) references part of a `String`:

```rust
let s = String::from("hello world");

let hello: &str = &s[0..5];   // "hello"
let world: &str = &s[6..11];  // "world"
```

The syntax `[start..end]` creates a slice from `start` to `end` (exclusive). Under the hood, a slice stores:
- A **pointer** to the starting position
- A **length** of the slice

### Range Syntax Shortcuts

Rust provides convenient shortcuts:

```rust
let s = String::from("hello");

// These are equivalent:
let slice = &s[0..2];   // Explicit start
let slice = &s[..2];    // Start from beginning

// These are equivalent:
let slice = &s[3..s.len()];  // Explicit end
let slice = &s[3..];         // Go to end

// These are equivalent:
let slice = &s[0..s.len()];  // Explicit both
let slice = &s[..];          // Entire string
```

## How Slices Prevent Bugs

Now let's rewrite `first_word` to return a slice instead of an index:

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

The return type `&str` is a string slice. Now watch what happens when we try our buggy code:

```rust
fn main() {
    let mut s = String::from("hello world");
    
    let word = first_word(&s);  // word is a slice referencing s
    
    s.clear();  // ERROR!
    
    println!("the first word is: {word}");
}
```

**This now fails to compile!**

```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:6:5
   |
4  |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
5  |
6  |     s.clear();
   |     ^^^^^^^^^ mutable borrow occurs here
7  |
8  |     println!("the first word is: {word}");
   |                                  ------ immutable borrow later used here
```

### Why This Error Occurs

Let's break down the borrowing:

1. `first_word(&s)` creates an **immutable borrow** of `s`
2. The returned slice `word` maintains this borrow (it references data inside `s`)
3. `s.clear()` needs a **mutable borrow** to modify `s`
4. `println!` uses `word`, so the immutable borrow is still active

**The borrowing rules forbid having both mutable and immutable references simultaneously.** The slice maintains a live reference to `s`'s data, preventing mutation that would invalidate the slice.

## Slices Remove Permissions

To understand this deeper, consider how slices affect permissions:

```rust
fn main() {
    let mut s = String::from("hello");
    // s has: Read, Write, Own permissions
    
    let hello: &str = &s[0..5];
    // s now has: Read only (Write removed while slice exists)
    // hello has: Read permission
    
    println!("{hello}");
    // hello goes out of scope
    
    // s regains Write permission
    s.push_str(" world");  // Now this works!
}
```

When `hello` (the slice) is created, `s` **loses write permission** until the slice is no longer used. This is the borrowing rule in action!

## Common Error: Mutating While Slice Exists

Here's a concrete example of why this protection matters:

```rust
fn main() {
    let mut s = String::from("hello");
    
    let slice = &s[0..2];  // slice points to "he"
    
    s.push_str(" world");  // ERROR: s is borrowed
    
    println!("{slice}");   // Would print garbage if allowed!
}
```

```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let slice = &s[0..2];
  |                  - immutable borrow occurs here
5 |
6 |     s.push_str(" world");
  |     ^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{slice}");
  |               ------- immutable borrow later used here
```

**Why would this be dangerous?** `push_str` might reallocate the `String`'s internal buffer to a new memory location. If that happened, `slice` would point to freed memory—a use-after-free bug! Rust prevents this at compile time.

### Solution: Shorten Slice Lifetime

Finish using the slice before mutating:

```rust
fn main() {
    let mut s = String::from("hello");
    
    let slice = &s[0..2];
    println!("{slice}");  // Use the slice
    // slice is no longer used after this point
    
    s.push_str(" world");  // OK: no active borrows
    println!("{s}");
}
```

Or clone if you need both:

```rust
fn main() {
    let mut s = String::from("hello");
    
    let slice_copy = s[0..2].to_string();  // Create owned copy
    
    s.push_str(" world");  // OK: slice_copy is independent
    
    println!("{slice_copy}");  // "he"
    println!("{s}");           // "hello world"
}
```

## String Literals Are Slices

A string literal is actually a slice:

```rust
let s = "Hello, world!";  // Type is &str
```

The type of `s` is `&str`—a slice pointing to a specific location in the binary. This is why string literals are **immutable**: `&str` is an immutable reference.

## Better Function Signatures with Slices

Using `&str` instead of `&String` makes functions more flexible:

```rust
// Less flexible: only accepts &String
fn first_word_v1(s: &String) -> &str {
    // ...
}

// More flexible: accepts &String, &str, and slices
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}
```

Now the function works with multiple types:

```rust
fn main() {
    let my_string = String::from("hello world");

    // Works with slices of String
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    
    // Works with references to String (deref coercion)
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // Works with slices of string literals
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);
    
    // String literals ARE slices, so this works directly!
    let word = first_word(my_string_literal);
}
```

**Best practice**: Accept `&str` instead of `&String` when you only need to read string data.

## Array Slices

Slices work on arrays too:

```rust
let a = [1, 2, 3, 4, 5];

let slice: &[i32] = &a[1..3];  // [2, 3]

assert_eq!(slice, &[2, 3]);
```

The type `&[i32]` is a slice of `i32` values. It works the same way as string slices—storing a pointer and length.

### Array Slice Error Example

The same borrowing rules apply:

```rust
fn main() {
    let mut a = [1, 2, 3, 4, 5];
    
    let slice = &a[1..3];  // Immutable borrow
    
    a[0] = 10;  // ERROR: cannot borrow as mutable
    
    println!("{:?}", slice);
}
```

```
error[E0502]: cannot borrow `a[_]` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let slice = &a[1..3];
  |                  - immutable borrow occurs here
5 |
6 |     a[0] = 10;
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{:?}", slice);
  |                      ----- immutable borrow later used here
```

Even though `slice` only covers indices 1-2 and we're modifying index 0, Rust conservatively treats this as a conflict. For advanced cases, use `split_at_mut`:

```rust
fn main() {
    let mut a = [1, 2, 3, 4, 5];
    
    let (left, right) = a.split_at_mut(1);
    // left is &mut [1], right is &mut [2, 3, 4, 5]
    
    left[0] = 10;           // Modify first element
    let slice = &right[0..2];  // Borrow from right portion
    
    println!("{:?}", slice);  // [2, 3]
}
```

## UTF-8 Boundary Warning

String slices must fall on valid UTF-8 character boundaries:

```rust
let hello = "Здравствуйте";  // Russian "Hello"

// Each Cyrillic character is 2 bytes!
let s = &hello[0..2];  // OK: first character "З"
let s = &hello[0..1];  // PANIC: slices in middle of character!
```

For non-ASCII strings, use methods like `.chars()` to safely iterate:

```rust
let hello = "Здравствуйте";
for c in hello.chars() {
    println!("{c}");
}
```

## Summary

| Concept | Key Points |
|---------|------------|
| **Index approach** | Disconnected from data; can become stale |
| **Slice approach** | Maintains borrowing relationship; compiler-enforced validity |
| **String slice `&str`** | Fat pointer (ptr + len); immutable reference to string data |
| **Array slice `&[T]`** | Fat pointer to contiguous elements of type `T` |
| **Slice permissions** | Creating a slice removes write permission from source |
| **Function signatures** | Prefer `&str` over `&String` for flexibility |

### Why Slices Are Safer Than Indices

```rust
// Index approach: compiles but has logic bugs
let mut s = String::from("hello");
let idx = 5;
s.clear();
// idx is now meaningless!

// Slice approach: compiler catches the bug
let mut s = String::from("hello");
let slice = &s[..];
s.clear();  // ERROR: cannot borrow as mutable
```

Slices tie references to data, enabling the borrow checker to prevent:
- Use-after-free bugs
- Data races
- Iterator invalidation

In the next post, we'll recap ownership concepts and solidify your understanding of Rust's memory safety guarantees.


+++
title = "Rust 107-1: Defining Modules to Control Scope and Privacy"
date = "2026-07-20"
tags = ["rust", "modules", "scope", "privacy", "visibility", "organization", "programming"]
categories = ["posts"]
series = ["Rust 107"]
type = "post"
draft = false
math = false
description = "Organize your Rust code with modules, controlling scope and privacy to build maintainable crates."
+++

Welcome to Rust 107-1! As your Rust projects grow, organizing code becomes crucial. Modules let you group related code, control visibility, and manage scope. This post explores defining modules to control scope and privacy, with code examples illustrating key principles.

## Modules Cheat Sheet

Before diving in, here's a quick reference:

- **Crate root**: Compiler starts from `src/lib.rs` (library) or `src/main.rs` (binary).
- **Declaring modules**: Use `mod module_name;` in crate root. Code can be inline, in `src/module_name.rs`, or `src/module_name/mod.rs`.
- **Submodules**: Declare with `mod` in parent files. Look in `src/parent/sub.rs` or `src/parent/sub/mod.rs`.
- **Paths**: Refer to items like `crate::module::item`.
- **Privacy**: Items are private by default. Use `pub` to make public.
- **use keyword**: Shortcuts for paths, e.g., `use crate::module::item;`.

Example crate structure:

```
backyard
├── src
│   ├── garden
│   │   └── vegetables.rs
│   ├── garden.rs
│   └── main.rs
```

In `src/main.rs`:

```rust
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {plant:?}!");
}
```

In `src/garden.rs`:

```rust
pub mod vegetables;
```

In `src/garden/vegetables.rs`:

```rust
#[derive(Debug)]
pub struct Asparagus {}
```

This illustrates module declaration and public visibility.

## Grouping Related Code in Modules

Modules organize code like directories. Items inside are private by default, hiding implementation details.

Consider a restaurant library. In `src/lib.rs`:

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {
            println!("Added to waitlist!");
        }

        fn seat_at_table() {} // Private
    }

    mod serving { // Private module
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}

pub fn eat_at_restaurant() {
    // Public function calls public submodule function
    crate::front_of_house::hosting::add_to_waitlist();
}

#[cfg(test)]
mod tests {
    use super::eat_at_restaurant;

    #[test]
    fn test_eat() {
        eat_at_restaurant(); // Should print
    }
}
```

**Principle: Privacy by default** - `serving` is private, so external code can't access it. `hosting` is public, but `seat_at_table` is private.

The module tree:

```
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist (pub)
     │   └── seat_at_table (private)
     └── serving (private)
         ├── take_order
         ├── serve_order
         └── take_payment
```

This structure makes code navigable and secure.

## Summary

Modules are fundamental for Rust code organization. They control scope and privacy, ensuring only necessary parts are exposed. Use `pub` judiciously to maintain encapsulation.

In the next post, we'll explore paths for referring to items in the module tree.

Stay tuned for more Rust!
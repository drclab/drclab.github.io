+++
title = "Rust 104-2: References and Borrowing"
date = "2026-01-10"
tags = ["rust", "references", "borrowing", "memory-safety", "programming"]
categories = ["posts"]
series = ["Rust 104"]
type = "post"
draft = false
math = true
description = "Exploring Rust's borrowing system, including references, permissions, and the borrow checker."
+++

Welcome to Rust 104-2! Building on our understanding of ownership, we'll now explore **references and borrowing**—Rust's mechanism for temporarily lending access to data without transferring ownership. This system allows for efficient, safe code while maintaining Rust's memory safety guarantees.

## References: Non-Owning Pointers

References are pointers that don't own the data they point to. They're created using the `&` operator and allow you to read or write data without taking ownership.

```rust
fn main() {
    let m1 = String::from("Hello");
    let m2 = String::from("world");
    greet(&m1, &m2); // Borrow the strings
    let s = format!("{} {}", m1, m2); // m1 and m2 are still valid
}

fn greet(g1: &String, g2: &String) {
    println!("{} {}!", g1, g2);
}
```

Here, `&m1` creates a reference to `m1`. The function `greet` receives references, allowing it to read the strings without moving them. After `greet` returns, `m1` and `m2` are still accessible.

## Dereferencing: Accessing Data Through Pointers

To access the data a reference points to, use the dereference operator `*`:

```rust
let mut x: Box<i32> = Box::new(1);
let a: i32 = *x;         // Read the heap value
*x += 1;                 // Modify the heap value

let r1: &Box<i32> = &x;  // Reference to the box
let b: i32 = **r1;       // Two dereferences to get to the value

let r2: &i32 = &*x;      // Reference directly to the heap value
let c: i32 = *r2;        // One dereference needed
```

Rust often performs dereferencing implicitly, especially in method calls:

```rust
let x: Box<i32> = Box::new(-1);
let x_abs1 = i32::abs(*x); // Explicit dereference
let x_abs2 = x.abs();      // Implicit dereference
```

## Avoiding Simultaneous Aliasing and Mutation

One of Rust's key safety principles is: **data should never be aliased and mutated at the same time**. References enforce this through a system of permissions.

### Permissions on Places

Every place (variable, dereference, array access, etc.) has permissions:
- **Read (R)**: Can copy data
- **Write (W)**: Can mutate data  
- **Own (O)**: Can move or drop data

By default, variables have RWO permissions. References temporarily transfer these permissions.

```rust
let mut v: Vec<i32> = vec![1, 2, 3];
let num: &i32 = &v[2]; // Borrows v, removing W and O from v
println!("Third element is {}", *num);
// num goes out of scope, permissions return to v
v.push(4); // Now safe to mutate v
```

### The Borrow Checker

The borrow checker enforces permission rules at compile-time. It prevents unsafe operations like mutating data while it's borrowed:

```rust
let mut v: Vec<i32> = vec![1, 2, 3];
let num: &i32 = &v[2];
v.push(4); // ERROR: cannot borrow `v` as mutable because it's also borrowed as immutable
println!("Third element is {}", *num);
```

This prevents undefined behavior from invalidated references.

## Mutable References: Unique Access

Mutable references (`&mut`) provide temporary exclusive access to data:

```rust
let mut v: Vec<i32> = vec![1, 2, 3];
let num: &mut i32 = &mut v[2]; // Borrows v exclusively
*num += 1; // Can mutate through the reference
println!("Third element is {}", *num);
// num goes out of scope, v is accessible again
println!("Vector is now {:?}", v);
```

Key differences from immutable references:
- The borrowed place loses ALL permissions while the mutable reference exists
- The dereferenced mutable reference has write permission

You can downgrade mutable references to immutable ones:

```rust
let mut v: Vec<i32> = vec![1, 2, 3];
let num: &mut i32 = &mut v[2];
let num2: &i32 = &*num; // Downgrade to immutable reference
println!("{} {}", *num, *num2); // Both readable
```

## Lifetimes: Reference Validity

A reference's **lifetime** is the span of code from its creation to its last use. Permissions return when lifetimes end.

Lifetimes can be non-contiguous with control flow:

```rust
fn ascii_capitalize(v: &mut Vec<char>) {
    let c = &v[0];
    if c.is_ascii_lowercase() {
        let up = c.to_ascii_uppercase();
        v[0] = up; // c's lifetime ends here in this branch
    } else {
        println!("Already capitalized: {:?}", v); // c's lifetime ends here in this branch
    }
    // v is mutable again
}
```

## Data Must Outlive References

References cannot outlive the data they point to. The borrow checker ensures this through permissions and lifetime parameters.

Attempting to return a reference to local data fails:

```rust
fn return_a_string() -> &String {
    let s = String::from("Hello world");
    &s // ERROR: s does not live long enough
}
```

For functions returning references, Rust uses lifetime parameters to track relationships between input and output references.

## Summary

References and borrowing allow Rust to provide flexible, efficient access to data while maintaining memory safety:

- **Immutable references** (`&T`) allow shared, read-only access
- **Mutable references** (`&mut T`) provide exclusive, read-write access  
- The **borrow checker** enforces permission rules to prevent unsafe aliasing and mutation
- **Lifetimes** define when references are valid and permissions are returned

This system enables Rust's zero-cost abstractions—safe code that performs as well as unsafe code, without runtime overhead. Understanding borrowing is key to writing idiomatic Rust.

In the next post, we'll look at common ownership and borrowing patterns, and how to fix related compiler errors.

Stay tuned for more Rust insights!
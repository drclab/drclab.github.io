+++
title = "Rust 104-5: Ownership Recap - Contrasting with Python"
date = "2026-01-11"
tags = ["rust", "ownership", "python", "memory-management", "garbage-collection", "programming"]
categories = ["posts"]
series = ["Rust 104"]
type = "post"
draft = true
math = false
description = "A comprehensive recap of Rust's ownership system, contrasted with Python's automatic memory management."
+++

Welcome to Rust 104-5! In this post, we'll recap the core concepts of Rust's ownership system while contrasting it with Python's approach to memory management. Understanding these differences will help you appreciate why Rust's model leads to safer, more predictable code.

## Ownership vs. Garbage Collection

Most languages, including Python, use **garbage collection (GC)** to manage memory automatically. Python employs reference counting with periodic tracing GC to reclaim unused memory. This avoids manual memory management but introduces trade-offs.

### Python's Approach

In Python, memory is managed transparently:

```python
class Document:
    def __init__(self, words):
        self.words = words

    def add_word(self, word):
        self.words.append(word)
        
    def get_words(self):
        return self.words

# Usage
words = ["Hello"]
d = Document(words)
d2 = Document(d.get_words())  # Shares reference to same list
d2.add_word("world")

print(d.get_words())  # ['Hello', 'world'] - d was modified!
```

**Key issues:**
- **Unpredictable deallocation**: When is `words` freed? It's hard to predict from the code.
- **Implicit sharing**: `d.get_words()` returns a reference, allowing unintended mutations.
- **Runtime overhead**: Reference counting adds small overhead to every operation; tracing GC causes occasional pauses.

### Rust's Ownership Model

Rust replaces GC with **ownership** - a compile-time discipline ensuring memory safety without runtime costs:

```rust
type Document = Vec<String>;

fn new_document(words: Vec<String>) -> Document {
    words  // Takes ownership
}

fn add_word(this: &mut Document, word: String) {
    this.push(word);  // Requires mutable borrow
}

fn get_words(this: &Document) -> &[String] {
    this.as_slice()  // Returns immutable slice
}

// Usage
fn main() {
    let words = vec!["Hello".to_string()];
    let d = new_document(words);
    
    let words_copy = get_words(&d).to_vec();  // Explicit copy
    let mut d2 = new_document(words_copy);
    add_word(&mut d2, "world".to_string());
    
    // d is unchanged
    assert!(!get_words(&d).contains(&"world".to_string()));
}
```

**Benefits:**
- **Predictable deallocation**: Data freed when owner goes out of scope.
- **Explicit sharing**: Must explicitly copy or borrow; no accidental mutations.
- **Zero runtime cost**: No GC overhead; memory managed at compile-time.

## Ownership at Runtime

Rust's memory model is explicit:

### Stack vs. Heap

- **Stack**: Fast, automatic allocation/deallocation for function-local data.
- **Heap**: Dynamic allocation via `Box<T>`, `Vec<T>`, `String`, etc.

```rust
fn main() {
    let mut a_num = 0;  // Stack
    inner(&mut a_num);
}

fn inner(x: &mut i32) {  // Reference to stack variable
    let another_num = 1;  // Stack
    let a_stack_ref = &another_num;  // Reference to stack
    let a_box = Box::new(2);  // Heap allocation
    let a_box_stack_ref = &a_box;  // Reference to box on stack
    let a_box_heap_ref = &*a_box;  // Reference to heap data
    
    *x += 5;  // Modifies caller's stack variable
}
```

### Pointers in Rust

- **Boxes**: Owning pointers (`Box<T>`) - allocate on heap, own the data.
- **References**: Non-owning pointers (`&T`, `&mut T`) - borrow data temporarily.
- **Slices**: References to contiguous sequences (`&[T]`, `&str`).

```rust
let s = String::from("abcdefg");  // Heap string
let s_slice = &s[2..5];  // "cde" - slice of heap data
```

**Contrast with Python**: Python hides pointers; everything looks like direct access. Rust makes pointer operations explicit, preventing accidental sharing or invalidation.

## Ownership at Compile-Time

Rust tracks **permissions** on each place (variable, field, etc.):
- **R (Read)**: Can copy data
- **W (Write)**: Can mutate data  
- **O (Own)**: Can move or drop data

### Moves and Permissions

Moves transfer ownership, removing permissions from the source:

```rust
let s = String::from("Hello");  // s: RWO
consume_a_string(s);  // s moved, loses all permissions
// println!("{}", s);  // ERROR: use of moved value
```

**Python parallel**: Variables are always references; "moving" doesn't exist - data persists until GC collects it.

### Borrowing

Borrowing temporarily lends access:

**Immutable borrow** (`&T`):
```rust
let mut s = String::from("Hello");
let s_ref = &s;  // s loses W permission
println!("{}", s_ref);  // OK
// s.push_str(" world");  // ERROR: cannot mutate while borrowed
```

**Mutable borrow** (`&mut T`):
```rust
let mut s = String::from("Hello");
let s_ref = &mut s;  // s loses R, W, O permissions
s_ref.push_str(" world");  // OK
// println!("{}", s);  // ERROR: cannot access while mutably borrowed
```

**Python contrast**: No borrow checking - you can mutate shared data anytime, leading to bugs. Python's approach is more flexible but less safe.

### Preventing Undefined Behavior

Permissions prevent:
- **Use-after-free**: Immutable borrows block mutation that could invalidate references.
- **Double-free**: Cannot move out of references to owned data.
- **Data races**: Exclusive mutable borrows prevent concurrent access.

**Python**: Relies on GC to prevent use-after-free, but doesn't prevent data races or unintended sharing.

## Summary

Rust's ownership system provides:

- **Memory safety** without GC overhead
- **Predictable performance** - no GC pauses
- **Explicit control** over data sharing and mutation
- **Compile-time guarantees** against common bugs

Compared to Python's GC:
- **Safer**: Prevents entire classes of bugs at compile-time
- **Faster**: No runtime memory management costs
- **More predictable**: Clear when data is allocated/deallocated
- **Stricter**: Requires explicit design decisions about data ownership

While Python prioritizes ease of use and flexibility, Rust's approach enables systems programming with C-like performance and safety. Understanding ownership is key to writing idiomatic, efficient Rust code.

This concludes our Rust 104 series on ownership! The concepts here form the foundation for understanding structs, traits, and advanced Rust features.

Stay tuned for more Rust explorations!
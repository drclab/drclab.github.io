+++
title = "Rust 109-2: Recoverable Errors with Result"
date = "2026-01-29"
tags = ["rust", "error handling", "result", "propagation", "question mark operator"]
categories = ["posts"]
series = ["Rust 109"]
type = "post"
draft = false
math = false
description = "Learn how to handle recoverable errors in Rust using the Result enum, matching on different errors, and propagating errors with the ? operator."
+++

Welcome to Rust 109-2! While panics are for unrecoverable errors, most errors can be handled gracefully. Rust's `Result` enum lets you express that an operation might fail and gives calling code the choice of how to respond.

## The Result Enum

The `Result` enum has two variants:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

- `T` represents the success value type
- `E` represents the error value type

## Opening a File with Result

`File::open` returns a `Result<File, io::Error>`:

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {error:?}"),
    };
}
```

If the file exists, we get the file handle. If not, we panic with the error details.

## Matching on Different Errors

We can handle different error types differently. If the file doesn't exist, create it; otherwise, panic:

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {e:?}"),
            },
            _ => {
                panic!("Problem opening the file: {error:?}");
            }
        },
    };
}
```

The `io::Error` struct has a `kind()` method returning an `ErrorKind` enum with variants like `NotFound`.

### Using unwrap_or_else for Cleaner Code

The same logic with closures:

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}
```

## Shortcuts: unwrap and expect

For quick error handling, use `unwrap` or `expect`:

```rust
use std::fs::File;

fn main() {
    // unwrap: panics with a generic message on error
    let greeting_file = File::open("hello.txt").unwrap();

    // expect: panics with your custom message
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
```

In production code, prefer `expect` for more informative error messages.

## Propagating Errors

Instead of handling errors locally, you can return them to the caller:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

This gives the caller control over how to handle the error.

## The ? Operator

The `?` operator simplifies error propagation:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

If the `Result` is `Ok`, the value is extracted. If it's `Err`, the error is returned from the function immediately.

### Chaining with ?

You can chain method calls with `?`:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();
    File::open("hello.txt")?.read_to_string(&mut username)?;
    Ok(username)
}
```

Or use the even shorter `fs::read_to_string`:

```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```

## Using ? with Option

The `?` operator also works with `Option`:

```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
```

If `next()` returns `None`, the function returns `None` early. Otherwise, execution continues.

**Note:** You cannot mix `?` on `Result` and `Option` in the same function. Use `.ok()` on `Result` or `.ok_or()` on `Option` to convert between them.

## Using ? in main

By default, `main` returns `()`, so you can't use `?` directly. But `main` can return `Result`:

```rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;
    Ok(())
}
```

`Box<dyn Error>` means "any kind of error," making this signature flexible for any errors your code might produce.

When `main` returns `Ok(())`, the program exits with code 0. When it returns `Err`, it exits with a nonzero code.

## Summary

| Method | Use Case |
|--------|----------|
| `match` | Full control over error handling |
| `unwrap` | Quick prototyping, panics on error |
| `expect` | Like unwrap with a custom message |
| `?` | Propagate errors to the caller |
| `unwrap_or_else` | Handle errors with closures |

The `Result` type and `?` operator make error handling in Rust both safe and ergonomic. Next, we'll explore when to use `panic!` versus `Result`.

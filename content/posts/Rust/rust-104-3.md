+++
title = "Rust 104-3: Fixing Ownership Errors"
date = "2026-01-11"
tags = ["rust", "ownership", "borrowing", "errors", "programming"]
categories = ["posts"]
series = ["Rust 104"]
type = "post"
draft = false
math = false
description = "Common ownership and borrowing errors in Rust and how to fix them."
+++

Welcome to Rust 104-3! As you write more Rust code, you'll inevitably encounter ownership and borrowing errors from the borrow checker. These errors can be frustrating at first, but understanding them is key to writing safe, efficient Rust code. In this post, we'll explore common ownership errors and strategies for fixing them.

## Returning a Reference to the Stack

One frequent error occurs when trying to return a reference to data that lives only on the stack:

```rust
fn return_a_string() -> &String {
    let s = String::from("Hello world");
    &s // ERROR: s does not live long enough
}
```

This fails because `s` is deallocated when the function returns, leaving the reference dangling.

### Solutions

1. **Return owned data instead:**
```rust
fn return_a_string() -> String {
    let s = String::from("Hello world");
    s
}
```

2. **Return a string literal (lives forever):**
```rust
fn return_a_string() -> &'static str {
    "Hello world"
}
```

3. **Use reference counting:**
```rust
use std::rc::Rc;

fn return_a_string() -> Rc<String> {
    let s = Rc::new(String::from("Hello world"));
    Rc::clone(&s)
}
```

4. **Have the caller provide storage:**
```rust
fn return_a_string(output: &mut String) {
    output.replace_range(.., "Hello world");
}
```

Choose based on your needs: who should own the data and how long should it live?

## Not Enough Permissions

Another common issue is trying to mutate data through an immutable reference:

```rust
fn stringify_name_with_title(name: &Vec<String>) -> String {
    name.push(String::from("Esq.")); // ERROR: cannot borrow as mutable
    let full = name.join(" ");
    full
}
```

This is unsafe because `push` could reallocate the vector, invalidating other references.

### Solutions

1. **Clone the data:**
```rust
fn stringify_name_with_title(name: &Vec<String>) -> String {
    let mut name_clone = name.clone();
    name_clone.push(String::from("Esq."));
    let full = name_clone.join(" ");
    full
}
```

2. **Build the result without mutating input:**
```rust
fn stringify_name_with_title(name: &Vec<String>) -> String {
    let mut full = name.join(" ");
    full.push_str(" Esq.");
    full
}
```

The second approach is more efficient and idiomatic—only ask for the permissions you need.

## Aliasing and Mutating a Data Structure

Problems arise when you hold a reference to data while mutating the structure containing it:

```rust
fn add_big_strings(dst: &mut Vec<String>, src: &[String]) {
    let largest: &String = dst.iter().max_by_key(|s| s.len()).unwrap();
    for s in src {
        if s.len() > largest.len() {
            dst.push(s.clone()); // ERROR: cannot borrow as mutable
        }
    }
}
```

`push` could reallocate `dst`, invalidating `largest`.

### Solutions

1. **Clone the reference:**
```rust
fn add_big_strings(dst: &mut Vec<String>, src: &[String]) {
    let largest: String = dst.iter().max_by_key(|s| s.len()).unwrap().clone();
    // ... rest same
}
```

2. **Collect changes first:**
```rust
fn add_big_strings(dst: &mut Vec<String>, src: &[String]) {
    let largest: &String = dst.iter().max_by_key(|s| s.len()).unwrap();
    let to_add: Vec<String> = 
        src.iter().filter(|s| s.len() > largest.len()).cloned().collect();
    dst.extend(to_add);
}
```

3. **Copy just the needed data:**
```rust
fn add_big_strings(dst: &mut Vec<String>, src: &[String]) {
    let largest_len: usize = dst.iter().max_by_key(|s| s.len()).unwrap().len();
    for s in src {
        if s.len() > largest_len {
            dst.push(s.clone());
        }
    }
}
```

The third option is often most efficient—shorten reference lifetimes to avoid conflicts.

## Copying vs. Moving Out of a Collection

Confusion arises when trying to move owned data through a reference:

```rust
let v: Vec<String> = vec![String::from("Hello world")];
let s_ref: &String = &v[0];
let s: String = *s_ref; // ERROR: cannot move out of shared reference
```

This would cause a double-free: both `v` and `s` would try to deallocate the string.

### Solutions

1. **Use the reference directly:**
```rust
let v: Vec<String> = vec![String::from("Hello world")];
let s_ref: &String = &v[0];
println!("{s_ref}!"); // Just read through the reference
```

2. **Clone if you need ownership:**
```rust
let v: Vec<String> = vec![String::from("Hello world")];
let mut s: String = v[0].clone();
s.push('!');
println!("{s}");
```

3. **Remove from the collection:**
```rust
let mut v: Vec<String> = vec![String::from("Hello world")];
let mut s: String = v.remove(0);
s.push('!');
println!("{s}");
```

Types implementing `Copy` (like `i32`) can be copied through references, but heap-owning types like `String` cannot.

## Mutating Different Tuple Fields

Rust sometimes over-conservatively restricts borrowing. This safe code fails:

```rust
fn get_first(name: &(String, String)) -> &String {
    &name.0
}

fn main() {
    let mut name = (String::from("Ferris"), String::from("Rustacean"));
    let first = get_first(&name);
    name.1.push_str(", Esq."); // ERROR: cannot borrow as mutable
    println!("{first} {}", name.1);
}
```

The borrow checker sees `get_first` borrows "some part" of `name` and conservatively assumes both fields.

### Solutions

1. **Inline the borrow:**
```rust
let first = &name.0; // Instead of calling get_first
name.1.push_str(", Esq.");
```

2. **Use runtime borrowing checks (advanced):**
Use types like `RefCell` for interior mutability (covered in future chapters).

## Mutating Different Array Elements

Similar issues occur with arrays when Rust can't distinguish different indices:

```rust
let mut a = [0, 1, 2, 3];
let x = &mut a[1];
let y = &a[2]; // ERROR: cannot borrow as immutable
*x += *y;
```

Rust uses `a[_]` to represent all elements conservatively.

### Solutions

1. **Use slice methods:**
```rust
let mut a = [0, 1, 2, 3];
let (a_l, a_r) = a.split_at_mut(2);
let x = &mut a_l[1];
let y = &a_r[0];
*x += *y;
```

2. **Restructure to avoid simultaneous borrowing:**
Perform operations in sequence rather than simultaneously.

## Summary

When the borrow checker rejects your code:

1. **Is it actually unsafe?** If yes, fix the underlying issue (lifetime problems, permission violations, etc.)
2. **Is it safe but conservative?** Use workarounds like cloning, restructuring, or standard library functions

Common patterns:
- **Clone** when you need independent copies
- **Change function signatures** to match actual needs (owned vs borrowed parameters)
- **Shorten lifetimes** of borrows to avoid conflicts
- **Use collection methods** that handle borrowing internally

Understanding these errors will help you design better Rust APIs and write more idiomatic code. The borrow checker is your friend—its restrictions prevent bugs!

In the next post, we'll explore slices, another fundamental Rust abstraction.

Stay tuned for more Rust wisdom!
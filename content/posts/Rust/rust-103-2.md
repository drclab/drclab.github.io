+++
title = "Rust 103-2: Data Types"
date = "2026-01-05"
tags = ["rust", "scalar", "compound", "integer", "tuple", "array", "programming"]
categories = ["posts"]
series = ["Rust 101"]
type = "post"
draft = false
math = true
description = "An exploration of Rust's data types: scalar types (integers, floats, booleans, characters) and compound types (tuples, arrays)."
+++

In the previous post, [Rust 103-1]({{< ref "rust-103-1.md" >}}), we explored variables, mutability, and shadowing. Now we'll dive into Rust's data types, based on [Chapter 3.2 of The Rust Programming Language](https://doc.rust-lang.org/stable/book/ch03-02-data-types.html).

## Static Typing

Rust is a **statically typed** language, meaning the compiler must know the types of all variables at compile time. While Rust can often infer types from context, sometimes you must provide explicit type annotations:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

Without the `: u32` annotation, the compiler cannot determine which numeric type you want from `.parse()`.

## Scalar Types

A scalar type represents a single value. Rust has four primary scalar types:

- Integers
- Floating-point numbers
- Booleans
- Characters

### Integer Types

An integer is a number without a fractional component. Rust provides signed (`i`) and unsigned (`u`) integers in various sizes:

| Length | Signed | Unsigned |
|--------|--------|----------|
| 8-bit  | `i8`   | `u8`     |
| 16-bit | `i16`  | `u16`    |
| 32-bit | `i32`  | `u32`    |
| 64-bit | `i64`  | `u64`    |
| 128-bit| `i128` | `u128`   |
| arch   | `isize`| `usize`  |

- **Signed** integers can store negative values: $-(2^{n-1})$ to $2^{n-1} - 1$
- **Unsigned** integers store only non-negative values: $0$ to $2^n - 1$
- `isize` and `usize` depend on architecture (64 bits on 64-bit systems)

#### Integer Literals

You can write integer literals in multiple formats:

| Format | Example |
|--------|---------|
| Decimal | `98_222` |
| Hex | `0xff` |
| Octal | `0o77` |
| Binary | `0b1111_0000` |
| Byte (`u8` only) | `b'A'` |

Use `_` as a visual separator: `1_000_000` is the same as `1000000`.

**Tip**: When unsure, Rust defaults to `i32`. Use `isize`/`usize` for indexing collections.

#### Integer Overflow

Integer overflow behaves differently based on build mode:

- **Debug mode**: Rust panics at runtime on overflow
- **Release mode**: Rust performs two's complement wrapping (e.g., `256u8` becomes `0`)

To handle overflow explicitly, use these methods on numeric types:

| Method Family | Behavior |
|---------------|----------|
| `wrapping_*` | Always wrap (e.g., `wrapping_add`) |
| `checked_*` | Return `None` on overflow |
| `overflowing_*` | Return value and overflow boolean |
| `saturating_*` | Clamp to min/max value |

```rust
let x: u8 = 250;
let y = x.wrapping_add(10);  // y = 4 (wrapped)
let z = x.saturating_add(10); // z = 255 (clamped)
```

### Floating-Point Types

Rust has two floating-point types: `f32` (32-bit) and `f64` (64-bit, the default). Both follow the IEEE-754 standard.

```rust
fn main() {
    let x = 2.0;      // f64 (default)
    let y: f32 = 3.0; // f32
}
```

**Tip**: Use `f64` by defaultâ€”it has more precision and is roughly the same speed as `f32` on modern CPUs.

### Numeric Operations

Rust supports all standard mathematical operations:

```rust
fn main() {
    // Addition
    let sum = 5 + 10;

    // Subtraction
    let difference = 95.5 - 4.3;

    // Multiplication
    let product = 4 * 30;

    // Division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1 (truncates toward zero)

    // Remainder
    let remainder = 43 % 5;
}
```

Integer division truncates toward zero, discarding the fractional part.

### The Boolean Type

Booleans have two values: `true` and `false`. They are one byte in size.

```rust
fn main() {
    let t = true;
    let f: bool = false; // with explicit type annotation
}
```

Booleans are primarily used in conditionals like `if` expressions.

### The Character Type

The `char` type represents a Unicode Scalar Value and is 4 bytes in size. Use single quotes for `char` literals:

```rust
fn main() {
    let c = 'z';
    let z: char = 'â„¤';
    let heart_eyed_cat = 'ðŸ˜»';
}
```

`char` can represent:
- ASCII characters
- Accented letters
- Chinese, Japanese, Korean characters
- Emojis
- Zero-width spaces

Unicode scalar values range from `U+0000` to `U+D7FF` and `U+E000` to `U+10FFFF`.

**Note**: A Rust `char` is different from a "character" in common usage. We'll explore this more when discussing strings in a later post.

## Compound Types

Compound types group multiple values into one type. Rust has two primitive compound types: **tuples** and **arrays**.

### The Tuple Type

A tuple groups values of **different types** into one compound type with a **fixed length**.

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

#### Destructuring Tuples

Use pattern matching to extract values:

```rust
fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("The value of y is: {y}"); // 6.4
}
```

#### Accessing Tuple Elements

Use dot notation with the index:

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;
}
```

#### The Unit Type

An empty tuple `()` is called the **unit** type. It represents an empty value or empty return type. Expressions that don't return a value implicitly return `()`.

### The Array Type

An array is a collection of values of the **same type** with a **fixed length**. Arrays are allocated on the stack.

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

#### When to Use Arrays

Use arrays when:
- You know the number of elements won't change
- You want stack allocation
- You need a fixed-size collection

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

For dynamic sizing, use a `Vec` (vector) instead.

#### Array Type Annotation

Specify the type and length in square brackets:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

#### Initializing with Repeated Values

Create an array with the same value repeated:

```rust
let a = [3; 5]; // Same as [3, 3, 3, 3, 3]
```

#### Accessing Array Elements

Use square bracket indexing (0-based):

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];  // 1
    let second = a[1]; // 2
}
```

#### Invalid Array Access

Rust protects against out-of-bounds access with runtime checks:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;
    let element = a[index]; // Runtime panic!
}
```

This produces a panic:
```
thread 'main' panicked at src/main.rs:4:19:
index out of bounds: the len is 5 but the index is 10
```

This is an example of Rust's **memory safety** principlesâ€”the program exits rather than accessing invalid memory.

## Summary

| Category | Type | Description |
|----------|------|-------------|
| **Scalar** | `i8`-`i128`, `isize` | Signed integers |
| | `u8`-`u128`, `usize` | Unsigned integers |
| | `f32`, `f64` | Floating-point numbers |
| | `bool` | Boolean (`true`/`false`) |
| | `char` | Unicode scalar value |
| **Compound** | `(T1, T2, ...)` | Tuple (mixed types, fixed length) |
| | `[T; N]` | Array (same type, fixed length) |

In the next post, we'll explore functions in Rust.

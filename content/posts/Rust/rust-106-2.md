+++
title = "Rust 106-2: The match Control Flow Construct"
date = "2026-01-18"
tags = ["rust", "match", "control-flow", "patterns", "enums", "option", "programming"]
categories = ["posts"]
series = ["Rust 106"]
type = "post"
draft = false
math = false
description = "Dive into Rust's powerful match control flow construct, learning how to handle enums and options with exhaustive pattern matching."
+++

Welcome to Rust 106-2! In the previous post, we explored defining enums and attaching data to their variants. Now, we'll learn about the `match` control flow construct, which allows you to compare a value against a series of patterns and execute code based on which pattern matches. This is especially powerful when working with enums.

## The match Control Flow Construct

Think of a `match` expression as a coin-sorting machine: values slide down a track with various holes, falling through the first one they fit. Similarly, values go through each pattern in a `match`, executing the code of the first matching pattern.

Let's use coins as an example. We can write a function that determines a coin's value in cents:

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

The `match` keyword is followed by an expression (here, `coin`). Arms consist of a pattern, `=>`, and code. Patterns can be literals, variables, or more complex structures. The code is an expression whose value becomes the `match`'s result.

For multi-line code, use curly braces:

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

## Patterns That Bind to Values

Match arms can bind to parts of matched values, extracting data from enum variants. For example, let's modify our `Coin` enum to include state quarters:

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // ... other states
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

Now, we can bind the state in the match:

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {state:?}!");
            25
        }
    }
}
```

When `Coin::Quarter(UsState::Alaska)` matches `Coin::Quarter(state)`, `state` binds to `UsState::Alaska`, which we can use in the arm's code.

## Matching with Option<T>

`match` works great with `Option<T>`. Here's a function that adds 1 to an `Option<i32>` if it has a value:

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}
```

For `Some(5)`, it matches `Some(i)`, binds `i` to 5, and returns `Some(6)`. For `None`, it returns `None`.

## Matches Are Exhaustive

Rust requires `match` to cover all possibilities. This code won't compile:

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

Rust errors: "non-exhaustive patterns: `None` not covered". This prevents bugs like forgetting to handle `None`.

## Catch-All Patterns and the _ Placeholder

For handling specific cases and a default, use a catch-all pattern. In a dice game:

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
}
```

The `other` arm catches all other values. To ignore the value, use `_`:

```rust
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}
```

Or do nothing:

```rust
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (),
}
```

The catch-all must be last, as patterns are checked in order.

## How Matches Interact with Ownership

When matching non-copyable data like `String`, be careful with ownership. This compiles:

```rust
let opt: Option<String> = Some(String::from("Hello world"));
match opt {
    Some(_) => println!("Some!"),
    None => println!("None!"),
}
println!("{:?}", opt);
```

But this doesn't, because `s` moves the `String`:

```rust
let opt: Option<String> = Some(String::from("Hello world"));
match opt {
    Some(s) => println!("Some: {}", s),
    None => println!("None!"),
}
// println!("{:?}", opt); // Error: opt moved
```

To borrow instead, match on a reference:

```rust
let opt: Option<String> = Some(String::from("Hello world"));
match &opt {
    Some(s) => println!("Some: {}", s),
    None => println!("None!"),
}
println!("{:?}", opt); // Works
```

Rust pushes the reference down, so `s` is `&String`.

## Summary

`match` is Rust's powerful control flow for pattern matching. It ensures exhaustiveness, preventing bugs, and integrates seamlessly with enums and ownership. Combined with enums, it's a favorite feature for handling complex data.

In future posts, we'll explore more advanced patterns and other Rust features. Stay tuned!

Stay tuned for more Rust!
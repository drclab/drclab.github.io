+++
title = "Rust 105-1: Defining and Instantiating Structs"
date = "2026-01-14"
tags = ["rust", "structs", "data-structures", "programming"]
categories = ["posts"]
series = ["Rust 105"]
type = "post"
draft = false
math = false
description = "Learn how to define and use structs in Rust with practical code examples."
+++

Welcome to Rust 105-1! Structs are one of Rust's fundamental building blocks for creating custom data types. In this post, we'll explore how to define structs and create instances, with plenty of code examples to illustrate each concept.

## Defining Structs

Structs let you group related data together with named fields. Here's a basic user struct:

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

Each field has a name and type. Structs are similar to tuples but with named fields for clarity.

## Creating Instances

Create struct instances using curly braces with `field: value` pairs:

```rust
fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    
    println!("User: {} ({})", user1.username, user1.email);
}
```

Field order doesn't matter - you can specify them in any sequence.

## Accessing Fields

Use dot notation to access struct fields:

```rust
fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    
    println!("Email: {}", user1.email);
    println!("Active: {}", user1.active);
    println!("Sign-ins: {}", user1.sign_in_count);
}
```

## Mutable Instances

Make structs mutable to change field values:

```rust
fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    
    user1.email = String::from("anotheremail@example.com");
    println!("Updated email: {}", user1.email);
}
```

The entire instance must be mutable - you can't mark individual fields as mutable.

## Field Init Shorthand

When parameter names match field names, use shorthand syntax:

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,  // Same as username: username
        email,     // Same as email: email
        sign_in_count: 1,
    }
}

fn main() {
    let user = build_user(
        String::from("user@example.com"),
        String::from("rustacean")
    );
    println!("Created user: {}", user.username);
}
```

## Struct Update Syntax

Create new instances based on existing ones:

```rust
fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    
    // Create user2 with most fields from user1
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1  // Copy remaining fields from user1
    };
    
    println!("User1: {}", user1.username);
    println!("User2: {}", user2.username);
}
```

Note: `..user1` moves data, so `user1` becomes partially invalid. Fields that implement `Copy` (like `bool` and `u64`) remain accessible.

## Tuple Structs

Tuple structs provide names for tuples without field names:

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    
    // Different types despite same field types
    // let point = black; // ERROR: mismatched types
    
    // Access by index
    println!("Black: ({}, {}, {})", black.0, black.1, black.2);
    
    // Destructure
    let Point(x, y, z) = origin;
    println!("Origin: x={}, y={}, z={}", x, y, z);
}
```

## Unit-Like Structs

Structs with no fields, useful for implementing traits:

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
    // Used for behavior, not data storage
}
```

## Ownership in Structs

Structs own their data by default. Use owned types like `String`:

```rust
struct User {
    active: bool,
    username: String,  // Owned string
    email: String,     // Owned string
    sign_in_count: u64,
}
```

References in structs require lifetimes (covered in future posts).

## Borrowing Struct Fields

Rust tracks borrowing at field level:

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut p = Point { x: 0, y: 0 };
    
    let x_ref = &mut p.x;  // Borrows p.x mutably
    *x_ref += 1;
    
    // p.y is still accessible
    println!("y = {}", p.y);
    
    // p as a whole is borrowed while x_ref exists
    // println!("Point: ({}, {})", p.x, p.y); // ERROR
}
```

## Practical Example: Rectangle

Let's build a complete example with a `Rectangle` struct:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };
    
    println!("rect1 area: {}", rect1.area());
    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
    
    // Debug print
    println!("rect1: {:?}", rect1);
}
```

This example demonstrates:
- Struct definition with `#[derive(Debug)]` for printing
- Associated functions (methods) with `impl`
- Borrowing with `&self` and `&Rectangle`

Structs are fundamental to Rust programming. They let you create meaningful data abstractions while maintaining memory safety and performance. Practice creating structs for your data models!

In the next post, we'll explore more advanced struct patterns and methods.

Stay tuned for more Rust code examples!
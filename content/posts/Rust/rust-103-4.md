+++
title = "Rust 103-4: Control Flow"
date = "2026-01-07"
tags = ["rust", "control-flow", "if", "loops", "while", "for", "match", "programming"]
categories = ["posts"]
series = ["Rust 101"]
type = "post"
draft = false
math = true
description = "An exploration of Rust control flow: if expressions, loops (loop, while, for), and how they differ from other languages."
+++

In the previous post, [Rust 103-3]({{< ref "rust-103-3.md" >}}), we explored functions in Rust. Now we'll dive into control flow, based on [Chapter 3.5 of The Rust Programming Language](https://rust-book.cs.brown.edu/ch03-05-control-flow.html).

## Overview

Control flow determines which code runs based on conditions and how many times code repeats. Rust provides:

- **`if` expressions** - branching based on conditions
- **Loops** - `loop`, `while`, and `for` for repetition

## `if` Expressions

An `if` expression branches code depending on conditions:

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

Key points:
- Starts with `if` followed by a condition
- Code blocks associated with conditions are called **arms** (like in `match`)
- The `else` block is optional—without it, the `if` block is simply skipped when false

### Conditions Must Be Boolean

Unlike Ruby or JavaScript, Rust **does not** automatically convert non-Boolean types to Boolean:

```rust
fn main() {
    let number = 3;

    if number {  // Error!
        println!("number was three");
    }
}
```

This produces:
```
error[E0308]: mismatched types
 --> src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer
```

You must be explicit:

```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```

### Multiple Conditions with `else if`

Chain multiple conditions using `else if`:

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

Output:
```
number is divisible by 3
```

**Important**: Rust executes only the **first** matching branch. Even though 6 is divisible by both 3 and 2, only "divisible by 3" prints.

**Tip**: Too many `else if` expressions can clutter code. Consider using `match` for complex branching (covered in Chapter 6).

### Using `if` in a `let` Statement

Because `if` is an **expression**, it returns a value! You can use it on the right side of a `let` statement:

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}"); // Prints: 5
}
```

The value of `number` depends on which block executes.

### Type Consistency Required

Both arms of an `if` expression must return the **same type**:

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { "six" }; // Error!
}
```

This produces:
```
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this
```

Rust must know the type of `number` at compile time to verify it's used correctly everywhere.

## Repetition with Loops

Rust has three kinds of loops: `loop`, `while`, and `for`.

### The `loop` Keyword

`loop` executes a block forever until you explicitly stop it:

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```

This prints "again!" infinitely until you press `Ctrl+C`.

#### Breaking Out of Loops

Use `break` to exit a loop:

```rust
fn main() {
    let mut counter = 0;

    loop {
        counter += 1;
        if counter == 10 {
            break;
        }
    }

    println!("Counter reached: {counter}");
}
```

Use `continue` to skip to the next iteration:

```rust
fn main() {
    let mut count = 0;

    loop {
        count += 1;
        
        if count % 2 == 0 {
            continue; // Skip even numbers
        }
        
        println!("{count}");
        
        if count >= 9 {
            break;
        }
    }
}
// Prints: 1, 3, 5, 7, 9
```

### Returning Values from Loops

One powerful use of `loop` is retrying operations. You can return a value from a loop using `break`:

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;  // Return this value
        }
    };

    println!("The result is {result}"); // Prints: 20
}
```

The value after `break` becomes the return value of the entire `loop` expression.

**Note**: You can also use `return` inside a loop, but `return` exits the entire **function**, while `break` only exits the loop.

### Loop Labels

When you have nested loops, `break` and `continue` apply to the **innermost** loop. To target an outer loop, use **loop labels**:

```rust
fn main() {
    let mut count = 0;
    
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;  // Exits inner loop only
            }
            if count == 2 {
                break 'counting_up;  // Exits outer loop
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

Output:
```
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
```

Loop labels must begin with a single quote (`'counting_up`).

### Conditional Loops with `while`

`while` loops while a condition is true:

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

Output:
```
3!
2!
1!
LIFTOFF!!!
```

This eliminates the nesting required with `loop` + `if` + `break`.

### Looping Through Collections with `for`

You can use `while` to loop through an array:

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);
        index += 1;
    }
}
```

But this approach is **error-prone**:
- If you change the array size but forget to update the condition, you'll panic
- The compiler adds runtime bounds checks on every iteration

#### The Better Way: `for` Loops

Use `for` to iterate over collections safely and concisely:

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

Benefits:
- **Safety**: No risk of going out of bounds
- **Conciseness**: No index variable to manage
- **Efficiency**: Compiler can optimize better (no bounds checks needed)

**`for` loops are the most commonly used loop construct in Rust.**

#### Looping with Ranges

Use `Range` for counting loops. Combine with `.rev()` to reverse:

```rust
fn main() {
    // Count from 1 to 3
    for number in 1..4 {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

Countdown version:

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

Output:
```
3!
2!
1!
LIFTOFF!!!
```

## Loop Comparison

| Loop Type | Use Case | Example |
|-----------|----------|---------|
| `loop` | Infinite loops, retry operations, return values | `loop { if done { break result; } }` |
| `while` | Loop while condition is true | `while count < 10 { ... }` |
| `for` | Iterate over collections or ranges | `for item in collection { ... }` |

## Practical Examples

### Example 1: Finding an Element

```rust
fn find_first_even(numbers: &[i32]) -> Option<i32> {
    for &num in numbers {
        if num % 2 == 0 {
            return Some(num);
        }
    }
    None
}

fn main() {
    let nums = [1, 3, 5, 8, 9];
    match find_first_even(&nums) {
        Some(n) => println!("First even: {n}"),
        None => println!("No even numbers found"),
    }
}
```

### Example 2: Retry with Timeout

```rust
fn main() {
    let mut attempts = 0;
    let max_attempts = 5;

    let result = loop {
        attempts += 1;
        println!("Attempt {attempts}...");

        // Simulate success on attempt 3
        if attempts == 3 {
            break "Success!";
        }

        if attempts >= max_attempts {
            break "Failed after max attempts";
        }
    };

    println!("{result}");
}
```

### Example 3: Nested Loop with Labels

```rust
fn main() {
    let matrix = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9],
    ];

    let target = 5;

    'outer: for (i, row) in matrix.iter().enumerate() {
        for (j, &value) in row.iter().enumerate() {
            if value == target {
                println!("Found {target} at position ({i}, {j})");
                break 'outer;
            }
        }
    }
}
```

## Summary

| Concept | Key Points |
|---------|------------|
| **`if` expression** | Condition must be `bool`; returns a value; arms must have same type |
| **`else if`** | Chain conditions; first match wins |
| **`loop`** | Infinite loop; exit with `break`; can return values |
| **Loop labels** | `'label: loop { ... break 'label; }` for nested loops |
| **`while`** | Conditional loop; cleaner than `loop` + `if` + `break` |
| **`for`** | Iterate collections/ranges; safest and most common |
| **Range** | `1..4` (exclusive) or `1..=4` (inclusive); use `.rev()` to reverse |

### Quick Reference

```rust
// if expression
let max = if a > b { a } else { b };

// Infinite loop with return value
let result = loop {
    if condition { break value; }
};

// while loop
while condition {
    // ...
}

// for loop over array
for element in array {
    // ...
}

// for loop with range
for i in 0..10 {
    // i goes from 0 to 9
}

// for loop with inclusive range
for i in 1..=10 {
    // i goes from 1 to 10
}

// Reverse iteration
for i in (1..4).rev() {
    // i goes 3, 2, 1
}
```

## Practice Exercises

The Rust Book suggests these exercises to practice Chapter 3 concepts:

1. **Temperature Converter**: Convert between Fahrenheit and Celsius
2. **Fibonacci Generator**: Generate the nth Fibonacci number
3. **Twelve Days of Christmas**: Print the lyrics, using loops for the repetition

In the next chapter, we'll explore **ownership**—Rust's most unique feature!


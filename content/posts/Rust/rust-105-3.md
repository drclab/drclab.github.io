+++
title = "Rust 105-3: Method Syntax"
date = "2026-01-16"
tags = ["rust", "methods", "impl", "self", "associated-functions", "programming"]
categories = ["posts"]
series = ["Rust 105"]
type = "post"
draft = false
math = false
description = "Master Rust's method syntax with practical examples of defining methods, associated functions, and understanding ownership."
+++

Welcome to Rust 105-3! Methods are functions associated with structs that operate on their data. In this post, we'll explore Rust's method syntax through runnable examples, covering everything from basic methods to advanced ownership concepts.

## Defining Methods

Methods are defined in `impl` blocks. The first parameter is always `self`, representing the instance:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect = Rectangle {
        width: 30,
        height: 50,
    };
    
    println!("Area: {}", rect.area());
}
```

## Method Parameters

Methods can take additional parameters beyond `self`:

```rust
impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };
    
    println!("rect1 can hold rect2: {}", rect1.can_hold(&rect2));
    println!("rect1 can hold rect3: {}", rect1.can_hold(&rect3));
}
```

## Mutable Methods

Use `&mut self` to modify the instance:

```rust
impl Rectangle {
    fn set_width(&mut self, width: u32) {
        self.width = width;
    }
    
    fn double_size(&mut self) {
        self.width *= 2;
        self.height *= 2;
    }
}

fn main() {
    let mut rect = Rectangle { width: 10, height: 20 };
    
    rect.set_width(15);
    println!("After set_width: {}x{}", rect.width, rect.height);
    
    rect.double_size();
    println!("After double_size: {}x{}", rect.width, rect.height);
}
```

## Associated Functions

Functions without `self` are called associated functions. They're often used as constructors:

```rust
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
    
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }
}

fn main() {
    let square = Rectangle::square(25);
    let rect = Rectangle::new(10, 20);
    
    println!("Square: {}x{}", square.width, square.height);
    println!("Rectangle: {}x{}", rect.width, rect.height);
}
```

## Multiple impl Blocks

You can split methods across multiple `impl` blocks:

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn perimeter(&self) -> u32 {
        2 * (self.width + self.height)
    }
    
    fn is_square(&self) -> bool {
        self.width == self.height
    }
}

fn main() {
    let rect = Rectangle { width: 10, height: 20 };
    let square = Rectangle::square(15);
    
    println!("Rectangle area: {}", rect.area());
    println!("Rectangle perimeter: {}", rect.perimeter());
    println!("Rectangle is square: {}", rect.is_square());
    
    println!("Square area: {}", square.area());
    println!("Square is square: {}", square.is_square());
}
```

## Method Calls vs Function Calls

Method calls are syntactic sugar for function calls:

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    fn set_width(&mut self, width: u32) {
        self.width = width;
    }
}

fn main() {
    let mut rect = Rectangle { width: 10, height: 20 };
    
    // Method call syntax
    let area1 = rect.area();
    
    // Equivalent function call syntax
    let area2 = Rectangle::area(&rect);
    
    assert_eq!(area1, area2);
    
    // Method call
    rect.set_width(15);
    
    // Equivalent function call
    Rectangle::set_width(&mut rect, 15);
    
    println!("Final size: {}x{}", rect.width, rect.height);
}
```

## Ownership and Methods

Methods can take ownership with `self`:

```rust
impl Rectangle {
    fn consume(self) -> (u32, u32) {
        (self.width, self.height)
    }
}

fn main() {
    let rect = Rectangle { width: 10, height: 20 };
    let (w, h) = rect.consume();
    
    // rect is moved and cannot be used here
    println!("Consumed: {}x{}", w, h);
    // println!("{}", rect.area()); // ERROR: rect moved
}
```

## Advanced Example: Point Operations

Let's build a more complex example with a `Point` struct:

```rust
#[derive(Debug, Copy, Clone)]
struct Point {
    x: f64,
    y: f64,
}

impl Point {
    fn new(x: f64, y: f64) -> Point {
        Point { x, y }
    }
    
    fn origin() -> Point {
        Point::new(0.0, 0.0)
    }
    
    fn distance_from_origin(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
    
    fn distance_to(&self, other: &Point) -> f64 {
        let dx = self.x - other.x;
        let dy = self.y - other.y;
        (dx.powi(2) + dy.powi(2)).sqrt()
    }
    
    fn translate(&mut self, dx: f64, dy: f64) {
        self.x += dx;
        self.y += dy;
    }
    
    fn midpoint(&self, other: &Point) -> Point {
        Point {
            x: (self.x + other.x) / 2.0,
            y: (self.y + other.y) / 2.0,
        }
    }
}

fn main() {
    let mut p1 = Point::new(3.0, 4.0);
    let p2 = Point::origin();
    
    println!("p1: {:?}", p1);
    println!("p2: {:?}", p2);
    println!("p1 distance from origin: {}", p1.distance_from_origin());
    println!("Distance between p1 and p2: {}", p1.distance_to(&p2));
    
    p1.translate(1.0, -2.0);
    println!("p1 after translation: {:?}", p1);
    
    let midpoint = p1.midpoint(&p2);
    println!("Midpoint of p1 and p2: {:?}", midpoint);
}
```

This example demonstrates:
- Associated functions for constructors
- Immutable methods (`&self`)
- Mutable methods (`&mut self`)
- Methods with multiple parameters
- Method chaining and composition

## Summary

Rust's method syntax provides a clean way to organize functionality around your data types:

- **Methods** take `&self`, `&mut self`, or `self` as the first parameter
- **Associated functions** don't take `self` and are called with `::` syntax
- **Method calls** are syntactic sugar for function calls with automatic borrowing
- **Ownership rules** apply to method parameters just like function parameters

Practice defining methods for your structs to create clean, object-oriented APIs while maintaining Rust's safety guarantees!

In the next post, we'll explore enums, Rust's other major data type.

Stay tuned for more Rust code examples!
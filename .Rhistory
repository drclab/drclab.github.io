# Set options to speed up sampling and avoid recompilation
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# Generate some fake data
set.seed(123)
y <- rbinom(30, size = 1, prob = 0.2)
# Define a simple Stan model
model_string <- "
data {
int<lower=0> n;
int<lower=0,upper=1> y[n];
}
parameters {
real<lower=0,upper=1> theta;
}
model {
y ~ bernoulli(theta);
}
"
# Fit the model
fit <- stan(model_code = model_string, data = list(n = length(y), y = y))
# Display results
print(fit)
traceplot(fit)
plot(fit)
# Display results
print(fit)
traceplot(fit)
plot(fit)
# Display results
print(fit)
traceplot(fit)
install.packages("elliptic")
library(rstan, lib.loc = "/usr/lib/R/site-library")
library(rstan, lib.loc = "/usr/lib/R/site-library")
library(rstan, lib.loc = "/usr/lib/R/site-library")
traceplot(fit)
detach("package:stats", unload = TRUE)
library(StanHeaders, lib.loc = "/usr/lib/R/site-library")
library(StanHeaders, lib.loc = "/usr/lib/R/site-library")
# Load the rstan library
library(rstan)
# Set options to speed up sampling and avoid recompilation
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# Generate some fake data
set.seed(123)
y <- rbinom(30, size = 1, prob = 0.2)
# Define a simple Stan model
model_string <- "
data {
int<lower=0> n;
int<lower=0,upper=1> y[n];
}
parameters {
real<lower=0,upper=1> theta;
}
model {
y ~ bernoulli(theta);
}
"
# Fit the model
fit <- stan(model_code = model_string, data = list(n = length(y), y = y))
# Display results
print(fit)
traceplot(fit)
plot(fit)
install.packages(c("progressr", "RcppArmadillo"))
install.packages("vroom")
install.packages(c("colorspace", "lavaan", "spatstat.explore"))
library(rstan)
traceplot(fit)
install.packages(c("ggsci", "pkgload"))
library(rstan)
traceplot(fit)
install.packages("forcats")
install.packages(c("nanoarrow", "spatstat.linnet"))
library(rstan, lib.loc = "/usr/lib/R/site-library")
library(rstan, lib.loc = "/usr/lib/R/site-library")
library(StanHeaders, lib.loc = "/usr/lib/R/site-library")
traceplot(fit)
library(rstan, lib.loc = "/usr/lib/R/site-library")
detach("package:rstan", unload = TRUE)
detach("package:stats", unload = TRUE)
library(rstan, lib.loc = "/usr/lib/R/site-library")
library(rstan)
traceplot(fit)
install.packages("rstanarm")
rm -rf /home/dulunche/R/x86_64-pc-linux-gnu-library/4.5/00LOCK-rstanarm
install.packages("rstanarm")
install.packages("terra")
install.packages("terra")
install.packages("gdtools")
install.packages("Hmisc")
install.packages("performance")
library(rstan)
traceplot(fit)
library(rstan)
traceplot(fit)
install.packages(c("glmmTMB", "textshaping", "units", "V8"))
install.packages(c("rversions", "statmod"))
install.packages("datawizard")
install.packages("geepack")
install.packages("igraph")
install.packages("scam")
install.packages("TMB")
library(rstan)
traceplot(fit)
# Toy admissions dataset: GPA + GRE scores predicting acceptance
students <- data.frame(
gpa = c(2.5, 3.2, 3.8, 2.9, 3.6, 3.1, 2.7, 3.9, 3.4, 2.8),
gre = c(480, 600, 720, 520, 700, 640, 500, 760, 660, 540),
admit = c(0, 0, 1, 0, 1, 1, 0, 1, 1, 0)
)
students$gre_std <- (students$gre - mean(students$gre)) / sd(students$gre)
students$gpa_std <- (students$gpa - mean(students$gpa)) / sd(students$gpa)
X <- as.matrix(students[, c("gre_std", "gpa_std")])
stan_data <- list(
N = nrow(students),
K = ncol(X),
X = X,
y = students$admit
)
library(rstan)
fit <- stan(
file = "logistic_regression.stan",
data = stan_data,
warmup = 1000,
iter = 2000,
chains = 4,
seed = 20251030
)
traceplot(fit)
traceplot(fit, pars = c("alpha", "beta"))
plot(fit)
ls
# Prepare environment -------------------------------------------------------
required_pkgs <- c("rstan")
missing_pkgs <- required_pkgs[!vapply(required_pkgs, requireNamespace, logical(1), quietly = TRUE)]
if (length(missing_pkgs) > 0) {
install.packages(missing_pkgs, repos = "https://cloud.r-project.org")
}
library(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# Compile Stan model --------------------------------------------------------
stan_file <- if (file.exists("stand_ode.stan")) {
"stand_ode.stan"
} else if (file.exists("content/ipynb/stand_ode.stan")) {
"content/ipynb/stand_ode.stan"
} else {
stop("Stan file not found next to this script.")
}
stand_ode_model <- stan_model(file = stan_file)
stand_ode_model <- rstan::stan_model(file = stan_file)
# Compile Stan model --------------------------------------------------------
stan_file <- if (file.exists("stand_ode.stan")) {
"stand_ode.stan"
} else if (file.exists("content/ipynb/stand_ode.stan")) {
"content/ipynb/stand_ode.stan"
} else {
stop("Stan file not found next to this script.")
}
stand_ode_model <- rstan::stan_model("stand_ode.stan")
stand_ode_model <- rstan::stan_model("./stand_ode.stan")
pwd()
# Compile Stan model --------------------------------------------------------
getwd()
stand_ode_model <- rstan::stan_model("~/drclab.github.io-1/content/ipynb/stand_ode.stan")
# Assemble example data -----------------------------------------------------
visit_schedule <- c(0.0, 7.0, 14.0, 28.0, 56.0, 84.0)
patient_data <- data.frame(
patient_id = rep(c("patient_01", "patient_02"), each = length(visit_schedule)),
time = rep(visit_schedule, times = 2),
bcva = c(
45.0, 47.5, 50.0, 54.0, 57.0, 58.5,
52.0, 54.0, 56.5, 60.0, 63.0, 64.0
)
)
print(patient_data)
# Prepare inputs for Stan ---------------------------------------------------
hyperparameters <- list(
lconc0 = 1.6,
K = 0.0045,
hill = 4.0,
r180 = 0.65,
beta = 0.35,
sigma_prior_scale = 5.0
)
make_stan_data <- function(df, hyper) {
list(
N = nrow(df),
time = df$time,
bcva_obs = df$bcva,
start_t = df$time[1],
lconc0 = hyper$lconc0,
K = hyper$K,
hill = hyper$hill,
r180 = hyper$r180,
beta = hyper$beta,
sigma_prior_scale = hyper$sigma_prior_scale
)
}
patient_slices <- split(patient_data, patient_data$patient_id)
stan_inputs <- lapply(patient_slices, make_stan_data, hyper = hyperparameters)
str(stan_inputs, max.level = 1)
# Fit the model for each patient --------------------------------------------
fit_list <- lapply(stan_inputs, function(data_list) {
rstan::sampling(
object = stand_ode_model,
data = data_list,
seed = 24531,
chains = 4,
iter = 1000,
warmup = 500,
refresh = 100,
control = list(adapt_delta = 0.9)
)
})
names(fit_list) <- names(stan_inputs)
print(fit_list)
# Summarize posterior parameters --------------------------------------------
target_params <- c("k_in", "k_out", "emax0", "lec50", "sigma", "R0")
extract_param_summary <- function(fit, id) {
sm <- summary(fit, pars = target_params)$summary
data.frame(
patient_id = id,
parameter = rownames(sm),
mean = sm[, "mean"],
sd = sm[, "sd"],
n_eff = sm[, "n_eff"],
rhat = sm[, "Rhat"],
row.names = NULL
)
}
parameter_summaries <- do.call(rbind, Map(extract_param_summary, fit_list, names(fit_list)))
print(parameter_summaries)
# Posterior predictive draws ------------------------------------------------
posterior_curves <- do.call(
rbind,
Map(function(fit, id) {
draws <- rstan::extract(fit, pars = "bcva_rep")$bcva_rep
mean_bcva <- apply(draws, 2, mean)
lower <- apply(draws, 2, quantile, probs = 0.05)
upper <- apply(draws, 2, quantile, probs = 0.95)
df <- patient_slices[[id]]
data.frame(
patient_id = id,
time = df$time,
observed = df$bcva,
posterior_mean = mean_bcva,
lower = lower,
upper = upper
)
}, fit_list, names(fit_list))
)
print(posterior_curves)
# Plot posterior predictive curves when interactive -------------------------
if (interactive()) {
op <- par(mfrow = c(1, length(patient_slices)))
for (id in names(patient_slices)) {
curve_df <- subset(posterior_curves, patient_id == id)
ylim_range <- range(c(curve_df$lower, curve_df$upper, curve_df$observed))
plot(
curve_df$time, curve_df$posterior_mean,
type = "l", lwd = 2, col = "darkorange",
ylim = ylim_range,
xlab = "Time (days)", ylab = "BCVA letters",
main = paste("Posterior predictive:", id)
)
polygon(
x = c(curve_df$time, rev(curve_df$time)),
y = c(curve_df$lower, rev(curve_df$upper)),
col = grDevices::adjustcolor("darkorange", alpha.f = 0.2),
border = NA
)
lines(curve_df$time, curve_df$posterior_mean, col = "darkorange", lwd = 2)
points(curve_df$time, curve_df$observed, pch = 16, col = "steelblue")
}
par(op)
}
# Summarize posterior parameters --------------------------------------------
summary(fit, c("k_in", "k_out", "emax0", "lec50", "sigma", "R0"))
rstan::sampling(
object = stand_ode_model,
data = data_list,
seed = 24531,
chains = 4,
iter = 1000,
warmup = 500,
refresh = 100,
control = list(adapt_delta = 0.9)
)
install.packages("terra")
set.seed(20250217L)
K <- 2L
J <- 6L
T <- 5L
J_prime <- 4L
T_prime <- 4L
x <- seq(-1, 1, length.out = T)
x_prime <- seq(-1.5, 1.5, length.out = T_prime)
mu_a_true <- c(0.7, 1.0)
delta_true <- c(0.25, -0.15)
beta_true <- -0.3
sigma_a_true <- c(0.4, 0.25)
sigma_y_true <- 0.2
eta_a <- matrix(rnorm(K * J), K, J)
a <- matrix(mu_a_true, K, J) + diag(sigma_a_true) %*% eta_a
y <- matrix(NA_real_, J, T)
for (j in 1:J) {
for (k in 1:T) {
mu_jk <- a[1, j] + a[2, j] * x[k] + beta_true * x[k]^2
y[j, k] <- rnorm(1, mean = mu_jk, sd = sigma_y_true)
}
}
eta_prime_a <- matrix(rnorm(K * J_prime), K, J_prime)
a_prime <- matrix(mu_a_true + delta_true, K, J_prime) +
diag(sigma_a_true) %*% eta_prime_a
y_prime <- matrix(NA_real_, J_prime, T_prime)
for (j in 1:J_prime) {
for (k in 1:T_prime) {
mu_prime_jk <- a_prime[1, j] +
a_prime[2, j] * x_prime[k] +
beta_true * x_prime[k]^2
y_prime[j, k] <- rnorm(1, mean = mu_prime_jk, sd = sigma_y_true)
}
}
K_phi <- 6L
mu_phi_p <- c(mu_a_true, beta_true, log(sigma_a_true), log(sigma_y_true))
Sigma_phi_p <- diag(c(1, 1, 1, 0.25, 0.25, 0.25))
mu_delta_p <- rep(0, K)
Sigma_delta_p <- diag(0.5, K)
J_tilde <- 10L
C <- 4L
xi <- array(rnorm(C * K * 2 * J_tilde), dim = c(C, K, 2 * J_tilde))
stan_data <- list(
fit_all = 0L,
fit_local = 0L,
J = J,
T = T,
K = K,
K_phi = K_phi,
y = y,
J_prime = J_prime,
T_prime = T_prime,
y_prime = y_prime,
x = x,
x_prime = x_prime,
mu_phi_p = mu_phi_p,
Sigma_phi_p = Sigma_phi_p,
mu_delta_p = mu_delta_p,
Sigma_delta_p = Sigma_delta_p,
J_tilde = J_tilde,
C = C,
CHAIN_ID = 1L,
xi = xi
)
str(stan_data)
if (!requireNamespace("rstan", quietly = TRUE)) {
stop("Package 'rstan' is required. Install it with install.packages('rstan').")
}
rstan::rstan_options(auto_write = TRUE)
options(mc.cores = min(2L, parallel::detectCores()))
stan_file <- file.path(script_dir, "stan", "linear_mvn_approx.stan")
args <- commandArgs(trailingOnly = FALSE)
script_arg <- grep("^--file=", args, value = TRUE)
script_dir <- if (length(script_arg)) {
dirname(normalizePath(sub("^--file=", "", script_arg)))
} else {
getwd()
}
stan_file <- file.path(script_dir, "stan", "linear_mvn_approx.stan")
if (!file.exists(stan_file)) {
stop("Stan model not found at ", stan_file)
}
(auto_write = TRUE)
(auto_write = TRUE)
rstan::rstan_options(auto_write = TRUE)
options(mc.cores = min(2L, parallel::detectCores()))
stan_file <- file.path(script_dir, "/content/ipynb/stan", "linear_mvn_approx.stan")
args <- commandArgs(trailingOnly = FALSE)
script_arg <- grep("^--file=", args, value = TRUE)
script_dir <- if (length(script_arg)) {
dirname(normalizePath(sub("^--file=", "", script_arg)))
} else {
getwd()
}
set.seed(20250217L)
K <- 2L
J <- 6L
T <- 5L
J_prime <- 4L
T_prime <- 4L
x <- seq(-1, 1, length.out = T)
x_prime <- seq(-1.5, 1.5, length.out = T_prime)
mu_a_true <- c(0.7, 1.0)
delta_true <- c(0.25, -0.15)
beta_true <- -0.3
sigma_a_true <- c(0.4, 0.25)
sigma_y_true <- 0.2
eta_a <- matrix(rnorm(K * J), K, J)
a <- matrix(mu_a_true, K, J) + diag(sigma_a_true) %*% eta_a
y <- matrix(NA_real_, J, T)
for (j in 1:J) {
for (k in 1:T) {
mu_jk <- a[1, j] + a[2, j] * x[k] + beta_true * x[k]^2
y[j, k] <- rnorm(1, mean = mu_jk, sd = sigma_y_true)
}
}
eta_prime_a <- matrix(rnorm(K * J_prime), K, J_prime)
a_prime <- matrix(mu_a_true + delta_true, K, J_prime) +
diag(sigma_a_true) %*% eta_prime_a
y_prime <- matrix(NA_real_, J_prime, T_prime)
for (j in 1:J_prime) {
for (k in 1:T_prime) {
mu_prime_jk <- a_prime[1, j] +
a_prime[2, j] * x_prime[k] +
beta_true * x_prime[k]^2
y_prime[j, k] <- rnorm(1, mean = mu_prime_jk, sd = sigma_y_true)
}
}
K_phi <- 6L
mu_phi_p <- c(mu_a_true, beta_true, log(sigma_a_true), log(sigma_y_true))
Sigma_phi_p <- diag(c(1, 1, 1, 0.25, 0.25, 0.25))
mu_delta_p <- rep(0, K)
Sigma_delta_p <- diag(0.5, K)
J_tilde <- 10L
C <- 4L
xi <- array(rnorm(C * K * 2 * J_tilde), dim = c(C, K, 2 * J_tilde))
stan_data <- list(
fit_all = 0L,
fit_local = 0L,
J = J,
T = T,
K = K,
K_phi = K_phi,
y = y,
J_prime = J_prime,
T_prime = T_prime,
y_prime = y_prime,
x = x,
x_prime = x_prime,
mu_phi_p = mu_phi_p,
Sigma_phi_p = Sigma_phi_p,
mu_delta_p = mu_delta_p,
Sigma_delta_p = Sigma_delta_p,
J_tilde = J_tilde,
C = C,
CHAIN_ID = 1L,
xi = xi
)
str(stan_data)
if (!requireNamespace("rstan", quietly = TRUE)) {
stop("Package 'rstan' is required. Install it with install.packages('rstan').")
}
rstan::rstan_options(auto_write = TRUE)
options(mc.cores = min(2L, parallel::detectCores()))
stan_file <- file.path(script_dir, "stan", "linear_mvn_approx.stan")
if (!file.exists(stan_file)) {
stop("Stan model not found at ", stan_file)
}
setwd("~/drclab.github.io-1/content/ipynb/stan")
stan_file <- file.path(script_dir, "stan", "linear_mvn_approx.stan")
args <- commandArgs(trailingOnly = FALSE)
script_arg <- grep("^--file=", args, value = TRUE)
script_dir <- if (length(script_arg)) {
dirname(normalizePath(sub("^--file=", "", script_arg)))
} else {
getwd()
}
set.seed(20250217L)
stan_file <- file.path(script_dir, "stan", "linear_mvn_approx.stan")
if (!file.exists(stan_file)) {
stop("Stan model not found at ", stan_file)
}
#===========================================================================
setwd("~/drclab.github.io-1/content/ipynb/")
stan_file <- file.path(script_dir, "stan", "linear_mvn_approx.stan")
if (!file.exists(stan_file)) {
stop("Stan model not found at ", stan_file)
}
args <- commandArgs(trailingOnly = FALSE)
script_arg <- grep("^--file=", args, value = TRUE)
script_dir <- if (length(script_arg)) {
dirname(normalizePath(sub("^--file=", "", script_arg)))
} else {
getwd()
}
set.seed(20250217L)
(script_dir, "stan", "linear_mvn_approx.stan")
(script_dir, "stan", "linear_mvn_approx.stan")
(script_dir, "stan", "linear_mvn_approx.stan")
setwd("~/drclab.github.io-1")
#===========================================================================
setwd("~/drclab.github.io-1")
stan_file <- file.path(script_dir, "stan", "linear_mvn_approx.stan")
if (!file.exists(stan_file)) {
stop("Stan model not found at ", stan_file)
}
message("Compiling Stan model at ", stan_file, " ...")
stan_model <- rstan::stan_model(file = stan_file)
message("Sampling ...")
fit <- rstan::sampling(
stan_model,
data = stan_data,
chains = 1L,
iter = 500L,
warmup = 250L,
seed = 20250217L,
refresh = 100L
)
